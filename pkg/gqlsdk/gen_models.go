// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package gqlsdk

import (
	"fmt"
	"io"
	"strconv"
)

// Boolean expression to compare columns of type "Boolean". All fields are combined with logical 'AND'.
type BooleanComparisonExp struct {
	Eq     *bool  `json:"_eq,omitempty"`
	Gt     *bool  `json:"_gt,omitempty"`
	Gte    *bool  `json:"_gte,omitempty"`
	In     []bool `json:"_in,omitempty"`
	IsNull *bool  `json:"_is_null,omitempty"`
	Lt     *bool  `json:"_lt,omitempty"`
	Lte    *bool  `json:"_lte,omitempty"`
	Neq    *bool  `json:"_neq,omitempty"`
	Nin    []bool `json:"_nin,omitempty"`
}

type CancelSubscriptionOutput struct {
	Status string `json:"status"`
}

type ChangeSubscriptionInput struct {
	IDPlan string `json:"id_plan"`
}

type ChangeSubscriptionOutput struct {
	IDAccount string `json:"id_account"`
	IsActive  bool   `json:"is_active"`
}

type CreateSubscriptionInput struct {
	PaymentMethodID string `json:"payment_method_id"`
}

type CreateSubscriptionOutput struct {
	IDAccount string `json:"id_account"`
	IsActive  bool   `json:"is_active"`
}

type InitSubscriptionInput struct {
	AccountName string `json:"account_name"`
	IDPlan      string `json:"id_plan"`
}

type InitSubscriptionOutput struct {
	IDAccount string `json:"id_account"`
}

type RetrySubscriptionInput struct {
	PaymentMethodID string `json:"payment_method_id"`
}

type RetrySubscriptionOutput struct {
	IDAccount string `json:"id_account"`
	IsActive  bool   `json:"is_active"`
}

type SaasGetCurrentAccountInput struct {
	IDUser string `json:"id_user"`
}

type SaasGetCurrentAccountOutput struct {
	IDAccount string `json:"id_account"`
	IDRole    string `json:"id_role"`
}

type SaasSetCurrentAccountInput struct {
	IDAccount string `json:"id_account"`
}

type SaasSetCurrentAccountOutput struct {
	IDAccount string `json:"id_account"`
}

// Boolean expression to compare columns of type "String". All fields are combined with logical 'AND'.
type StringComparisonExp struct {
	Eq  *string `json:"_eq,omitempty"`
	Gt  *string `json:"_gt,omitempty"`
	Gte *string `json:"_gte,omitempty"`
	// does the column match the given case-insensitive pattern
	Ilike *string  `json:"_ilike,omitempty"`
	In    []string `json:"_in,omitempty"`
	// does the column match the given POSIX regular expression, case insensitive
	Iregex *string `json:"_iregex,omitempty"`
	IsNull *bool   `json:"_is_null,omitempty"`
	// does the column match the given pattern
	Like *string `json:"_like,omitempty"`
	Lt   *string `json:"_lt,omitempty"`
	Lte  *string `json:"_lte,omitempty"`
	Neq  *string `json:"_neq,omitempty"`
	// does the column NOT match the given case-insensitive pattern
	Nilike *string  `json:"_nilike,omitempty"`
	Nin    []string `json:"_nin,omitempty"`
	// does the column NOT match the given POSIX regular expression, case insensitive
	Niregex *string `json:"_niregex,omitempty"`
	// does the column NOT match the given pattern
	Nlike *string `json:"_nlike,omitempty"`
	// does the column NOT match the given POSIX regular expression, case sensitive
	Nregex *string `json:"_nregex,omitempty"`
	// does the column NOT match the given SQL regular expression
	Nsimilar *string `json:"_nsimilar,omitempty"`
	// does the column match the given POSIX regular expression, case sensitive
	Regex *string `json:"_regex,omitempty"`
	// does the column match the given SQL regular expression
	Similar *string `json:"_similar,omitempty"`
}

// Boolean expression to compare columns of type "jsonb". All fields are combined with logical 'AND'.
type JsonbComparisonExp struct {
	// is the column contained in the given json value
	ContainedIn map[string]interface{} `json:"_contained_in,omitempty"`
	// does the column contain the given json value at the top level
	Contains map[string]interface{} `json:"_contains,omitempty"`
	Eq       map[string]interface{} `json:"_eq,omitempty"`
	Gt       map[string]interface{} `json:"_gt,omitempty"`
	Gte      map[string]interface{} `json:"_gte,omitempty"`
	// does the string exist as a top-level key in the column
	HasKey *string `json:"_has_key,omitempty"`
	// do all of these strings exist as top-level keys in the column
	HasKeysAll []string `json:"_has_keys_all,omitempty"`
	// do any of these strings exist as top-level keys in the column
	HasKeysAny []string                 `json:"_has_keys_any,omitempty"`
	In         []map[string]interface{} `json:"_in,omitempty"`
	IsNull     *bool                    `json:"_is_null,omitempty"`
	Lt         map[string]interface{}   `json:"_lt,omitempty"`
	Lte        map[string]interface{}   `json:"_lte,omitempty"`
	Neq        map[string]interface{}   `json:"_neq,omitempty"`
	Nin        []map[string]interface{} `json:"_nin,omitempty"`
}

// columns and relationships of "saas_account"
type SaasAccount struct {
	CreatedAt        string  `json:"created_at"`
	ID               string  `json:"id"`
	IDAddressInvoice *string `json:"id_address_invoice,omitempty"`
	Name             string  `json:"name"`
	// An object relationship
	SaasAddress *SaasAddress `json:"saas_address,omitempty"`
	// An array relationship
	SaasAddresses []*SaasAddress `json:"saas_addresses,omitempty"`
	// An aggregate relationship
	SaasAddressesAggregate *SaasAddressAggregate `json:"saas_addresses_aggregate,omitempty"`
	// An array relationship
	SaasMemberships []*SaasMembership `json:"saas_memberships,omitempty"`
	// An aggregate relationship
	SaasMembershipsAggregate *SaasMembershipAggregate `json:"saas_memberships_aggregate,omitempty"`
	// An object relationship
	SubscriptionCustomer *SubscriptionCustomer `json:"subscription_customer,omitempty"`
	// An object relationship
	SubscriptionStatus *SubscriptionStatus `json:"subscription_status,omitempty"`
	UpdatedAt          string              `json:"updated_at"`
}

// aggregated selection of "saas_account"
type SaasAccountAggregate struct {
	Aggregate *SaasAccountAggregateFields `json:"aggregate,omitempty"`
	Nodes     []*SaasAccount              `json:"nodes,omitempty"`
}

// aggregate fields of "saas_account"
type SaasAccountAggregateFields struct {
	Count int64                 `json:"count"`
	Max   *SaasAccountMaxFields `json:"max,omitempty"`
	Min   *SaasAccountMinFields `json:"min,omitempty"`
}

// Boolean expression to filter rows from the table "saas_account". All fields are combined with a logical 'AND'.
type SaasAccountBoolExp struct {
	And                  []*SaasAccountBoolExp        `json:"_and,omitempty"`
	Not                  *SaasAccountBoolExp          `json:"_not,omitempty"`
	Or                   []*SaasAccountBoolExp        `json:"_or,omitempty"`
	CreatedAt            *TimestamptzComparisonExp    `json:"created_at,omitempty"`
	ID                   *UUIDComparisonExp           `json:"id,omitempty"`
	IDAddressInvoice     *UUIDComparisonExp           `json:"id_address_invoice,omitempty"`
	Name                 *StringComparisonExp         `json:"name,omitempty"`
	SaasAddress          *SaasAddressBoolExp          `json:"saas_address,omitempty"`
	SaasAddresses        *SaasAddressBoolExp          `json:"saas_addresses,omitempty"`
	SaasMemberships      *SaasMembershipBoolExp       `json:"saas_memberships,omitempty"`
	SubscriptionCustomer *SubscriptionCustomerBoolExp `json:"subscription_customer,omitempty"`
	SubscriptionStatus   *SubscriptionStatusBoolExp   `json:"subscription_status,omitempty"`
	UpdatedAt            *TimestamptzComparisonExp    `json:"updated_at,omitempty"`
}

// input type for inserting data into table "saas_account"
type SaasAccountInsertInput struct {
	CreatedAt            *string                                `json:"created_at,omitempty"`
	ID                   *string                                `json:"id,omitempty"`
	IDAddressInvoice     *string                                `json:"id_address_invoice,omitempty"`
	Name                 *string                                `json:"name,omitempty"`
	SaasAddress          *SaasAddressObjRelInsertInput          `json:"saas_address,omitempty"`
	SaasAddresses        *SaasAddressArrRelInsertInput          `json:"saas_addresses,omitempty"`
	SaasMemberships      *SaasMembershipArrRelInsertInput       `json:"saas_memberships,omitempty"`
	SubscriptionCustomer *SubscriptionCustomerObjRelInsertInput `json:"subscription_customer,omitempty"`
	SubscriptionStatus   *SubscriptionStatusObjRelInsertInput   `json:"subscription_status,omitempty"`
	UpdatedAt            *string                                `json:"updated_at,omitempty"`
}

// aggregate max on columns
type SaasAccountMaxFields struct {
	CreatedAt        *string `json:"created_at,omitempty"`
	ID               *string `json:"id,omitempty"`
	IDAddressInvoice *string `json:"id_address_invoice,omitempty"`
	Name             *string `json:"name,omitempty"`
	UpdatedAt        *string `json:"updated_at,omitempty"`
}

// aggregate min on columns
type SaasAccountMinFields struct {
	CreatedAt        *string `json:"created_at,omitempty"`
	ID               *string `json:"id,omitempty"`
	IDAddressInvoice *string `json:"id_address_invoice,omitempty"`
	Name             *string `json:"name,omitempty"`
	UpdatedAt        *string `json:"updated_at,omitempty"`
}

// response of any mutation on the table "saas_account"
type SaasAccountMutationResponse struct {
	// number of rows affected by the mutation
	AffectedRows int64 `json:"affected_rows"`
	// data from the rows affected by the mutation
	Returning []*SaasAccount `json:"returning,omitempty"`
}

// input type for inserting object relation for remote table "saas_account"
type SaasAccountObjRelInsertInput struct {
	Data *SaasAccountInsertInput `json:"data,omitempty"`
	// on conflict condition
	OnConflict *SaasAccountOnConflict `json:"on_conflict,omitempty"`
}

// on conflict condition type for table "saas_account"
type SaasAccountOnConflict struct {
	Constraint    SaasAccountConstraint     `json:"constraint"`
	UpdateColumns []SaasAccountUpdateColumn `json:"update_columns,omitempty"`
	Where         *SaasAccountBoolExp       `json:"where,omitempty"`
}

// Ordering options when selecting data from "saas_account".
type SaasAccountOrderBy struct {
	CreatedAt                *OrderBy                        `json:"created_at,omitempty"`
	ID                       *OrderBy                        `json:"id,omitempty"`
	IDAddressInvoice         *OrderBy                        `json:"id_address_invoice,omitempty"`
	Name                     *OrderBy                        `json:"name,omitempty"`
	SaasAddress              *SaasAddressOrderBy             `json:"saas_address,omitempty"`
	SaasAddressesAggregate   *SaasAddressAggregateOrderBy    `json:"saas_addresses_aggregate,omitempty"`
	SaasMembershipsAggregate *SaasMembershipAggregateOrderBy `json:"saas_memberships_aggregate,omitempty"`
	SubscriptionCustomer     *SubscriptionCustomerOrderBy    `json:"subscription_customer,omitempty"`
	SubscriptionStatus       *SubscriptionStatusOrderBy      `json:"subscription_status,omitempty"`
	UpdatedAt                *OrderBy                        `json:"updated_at,omitempty"`
}

// primary key columns input for table: saas_account
type SaasAccountPkColumnsInput struct {
	ID string `json:"id"`
}

// input type for updating data in table "saas_account"
type SaasAccountSetInput struct {
	CreatedAt        *string `json:"created_at,omitempty"`
	ID               *string `json:"id,omitempty"`
	IDAddressInvoice *string `json:"id_address_invoice,omitempty"`
	Name             *string `json:"name,omitempty"`
	UpdatedAt        *string `json:"updated_at,omitempty"`
}

// columns and relationships of "saas_address"
type SaasAddress struct {
	Address    string  `json:"address"`
	City       string  `json:"city"`
	Country    string  `json:"country"`
	CreatedAt  string  `json:"created_at"`
	ID         string  `json:"id"`
	IDAccount  *string `json:"id_account,omitempty"`
	IDUser     string  `json:"id_user"`
	PostalCode string  `json:"postal_code"`
	// An object relationship
	SaasAccount *SaasAccount `json:"saas_account,omitempty"`
	UpdatedAt   string       `json:"updated_at"`
}

// aggregated selection of "saas_address"
type SaasAddressAggregate struct {
	Aggregate *SaasAddressAggregateFields `json:"aggregate,omitempty"`
	Nodes     []*SaasAddress              `json:"nodes,omitempty"`
}

// aggregate fields of "saas_address"
type SaasAddressAggregateFields struct {
	Count int64                 `json:"count"`
	Max   *SaasAddressMaxFields `json:"max,omitempty"`
	Min   *SaasAddressMinFields `json:"min,omitempty"`
}

// order by aggregate values of table "saas_address"
type SaasAddressAggregateOrderBy struct {
	Count *OrderBy               `json:"count,omitempty"`
	Max   *SaasAddressMaxOrderBy `json:"max,omitempty"`
	Min   *SaasAddressMinOrderBy `json:"min,omitempty"`
}

// input type for inserting array relation for remote table "saas_address"
type SaasAddressArrRelInsertInput struct {
	Data []*SaasAddressInsertInput `json:"data,omitempty"`
	// on conflict condition
	OnConflict *SaasAddressOnConflict `json:"on_conflict,omitempty"`
}

// Boolean expression to filter rows from the table "saas_address". All fields are combined with a logical 'AND'.
type SaasAddressBoolExp struct {
	And         []*SaasAddressBoolExp     `json:"_and,omitempty"`
	Not         *SaasAddressBoolExp       `json:"_not,omitempty"`
	Or          []*SaasAddressBoolExp     `json:"_or,omitempty"`
	Address     *StringComparisonExp      `json:"address,omitempty"`
	City        *StringComparisonExp      `json:"city,omitempty"`
	Country     *StringComparisonExp      `json:"country,omitempty"`
	CreatedAt   *TimestamptzComparisonExp `json:"created_at,omitempty"`
	ID          *UUIDComparisonExp        `json:"id,omitempty"`
	IDAccount   *UUIDComparisonExp        `json:"id_account,omitempty"`
	IDUser      *StringComparisonExp      `json:"id_user,omitempty"`
	PostalCode  *StringComparisonExp      `json:"postal_code,omitempty"`
	SaasAccount *SaasAccountBoolExp       `json:"saas_account,omitempty"`
	UpdatedAt   *TimestamptzComparisonExp `json:"updated_at,omitempty"`
}

// input type for inserting data into table "saas_address"
type SaasAddressInsertInput struct {
	Address     *string                       `json:"address,omitempty"`
	City        *string                       `json:"city,omitempty"`
	Country     *string                       `json:"country,omitempty"`
	CreatedAt   *string                       `json:"created_at,omitempty"`
	ID          *string                       `json:"id,omitempty"`
	IDAccount   *string                       `json:"id_account,omitempty"`
	IDUser      *string                       `json:"id_user,omitempty"`
	PostalCode  *string                       `json:"postal_code,omitempty"`
	SaasAccount *SaasAccountObjRelInsertInput `json:"saas_account,omitempty"`
	UpdatedAt   *string                       `json:"updated_at,omitempty"`
}

// aggregate max on columns
type SaasAddressMaxFields struct {
	Address    *string `json:"address,omitempty"`
	City       *string `json:"city,omitempty"`
	Country    *string `json:"country,omitempty"`
	CreatedAt  *string `json:"created_at,omitempty"`
	ID         *string `json:"id,omitempty"`
	IDAccount  *string `json:"id_account,omitempty"`
	IDUser     *string `json:"id_user,omitempty"`
	PostalCode *string `json:"postal_code,omitempty"`
	UpdatedAt  *string `json:"updated_at,omitempty"`
}

// order by max() on columns of table "saas_address"
type SaasAddressMaxOrderBy struct {
	Address    *OrderBy `json:"address,omitempty"`
	City       *OrderBy `json:"city,omitempty"`
	Country    *OrderBy `json:"country,omitempty"`
	CreatedAt  *OrderBy `json:"created_at,omitempty"`
	ID         *OrderBy `json:"id,omitempty"`
	IDAccount  *OrderBy `json:"id_account,omitempty"`
	IDUser     *OrderBy `json:"id_user,omitempty"`
	PostalCode *OrderBy `json:"postal_code,omitempty"`
	UpdatedAt  *OrderBy `json:"updated_at,omitempty"`
}

// aggregate min on columns
type SaasAddressMinFields struct {
	Address    *string `json:"address,omitempty"`
	City       *string `json:"city,omitempty"`
	Country    *string `json:"country,omitempty"`
	CreatedAt  *string `json:"created_at,omitempty"`
	ID         *string `json:"id,omitempty"`
	IDAccount  *string `json:"id_account,omitempty"`
	IDUser     *string `json:"id_user,omitempty"`
	PostalCode *string `json:"postal_code,omitempty"`
	UpdatedAt  *string `json:"updated_at,omitempty"`
}

// order by min() on columns of table "saas_address"
type SaasAddressMinOrderBy struct {
	Address    *OrderBy `json:"address,omitempty"`
	City       *OrderBy `json:"city,omitempty"`
	Country    *OrderBy `json:"country,omitempty"`
	CreatedAt  *OrderBy `json:"created_at,omitempty"`
	ID         *OrderBy `json:"id,omitempty"`
	IDAccount  *OrderBy `json:"id_account,omitempty"`
	IDUser     *OrderBy `json:"id_user,omitempty"`
	PostalCode *OrderBy `json:"postal_code,omitempty"`
	UpdatedAt  *OrderBy `json:"updated_at,omitempty"`
}

// response of any mutation on the table "saas_address"
type SaasAddressMutationResponse struct {
	// number of rows affected by the mutation
	AffectedRows int64 `json:"affected_rows"`
	// data from the rows affected by the mutation
	Returning []*SaasAddress `json:"returning,omitempty"`
}

// input type for inserting object relation for remote table "saas_address"
type SaasAddressObjRelInsertInput struct {
	Data *SaasAddressInsertInput `json:"data,omitempty"`
	// on conflict condition
	OnConflict *SaasAddressOnConflict `json:"on_conflict,omitempty"`
}

// on conflict condition type for table "saas_address"
type SaasAddressOnConflict struct {
	Constraint    SaasAddressConstraint     `json:"constraint"`
	UpdateColumns []SaasAddressUpdateColumn `json:"update_columns,omitempty"`
	Where         *SaasAddressBoolExp       `json:"where,omitempty"`
}

// Ordering options when selecting data from "saas_address".
type SaasAddressOrderBy struct {
	Address     *OrderBy            `json:"address,omitempty"`
	City        *OrderBy            `json:"city,omitempty"`
	Country     *OrderBy            `json:"country,omitempty"`
	CreatedAt   *OrderBy            `json:"created_at,omitempty"`
	ID          *OrderBy            `json:"id,omitempty"`
	IDAccount   *OrderBy            `json:"id_account,omitempty"`
	IDUser      *OrderBy            `json:"id_user,omitempty"`
	PostalCode  *OrderBy            `json:"postal_code,omitempty"`
	SaasAccount *SaasAccountOrderBy `json:"saas_account,omitempty"`
	UpdatedAt   *OrderBy            `json:"updated_at,omitempty"`
}

// primary key columns input for table: saas_address
type SaasAddressPkColumnsInput struct {
	ID string `json:"id"`
}

// input type for updating data in table "saas_address"
type SaasAddressSetInput struct {
	Address    *string `json:"address,omitempty"`
	City       *string `json:"city,omitempty"`
	Country    *string `json:"country,omitempty"`
	CreatedAt  *string `json:"created_at,omitempty"`
	ID         *string `json:"id,omitempty"`
	IDAccount  *string `json:"id_account,omitempty"`
	IDUser     *string `json:"id_user,omitempty"`
	PostalCode *string `json:"postal_code,omitempty"`
	UpdatedAt  *string `json:"updated_at,omitempty"`
}

// columns and relationships of "saas_membership"
type SaasMembership struct {
	CreatedAt string `json:"created_at"`
	ID        string `json:"id"`
	IDAccount string `json:"id_account"`
	IDRole    string `json:"id_role"`
	IDUser    string `json:"id_user"`
	// An object relationship
	SaasAccount *SaasAccount `json:"saas_account,omitempty"`
	// An object relationship
	SaasRole   *SaasRole `json:"saas_role,omitempty"`
	SelectedAt *string   `json:"selected_at,omitempty"`
	UpdatedAt  string    `json:"updated_at"`
}

// aggregated selection of "saas_membership"
type SaasMembershipAggregate struct {
	Aggregate *SaasMembershipAggregateFields `json:"aggregate,omitempty"`
	Nodes     []*SaasMembership              `json:"nodes,omitempty"`
}

// aggregate fields of "saas_membership"
type SaasMembershipAggregateFields struct {
	Count int64                    `json:"count"`
	Max   *SaasMembershipMaxFields `json:"max,omitempty"`
	Min   *SaasMembershipMinFields `json:"min,omitempty"`
}

// order by aggregate values of table "saas_membership"
type SaasMembershipAggregateOrderBy struct {
	Count *OrderBy                  `json:"count,omitempty"`
	Max   *SaasMembershipMaxOrderBy `json:"max,omitempty"`
	Min   *SaasMembershipMinOrderBy `json:"min,omitempty"`
}

// input type for inserting array relation for remote table "saas_membership"
type SaasMembershipArrRelInsertInput struct {
	Data []*SaasMembershipInsertInput `json:"data,omitempty"`
	// on conflict condition
	OnConflict *SaasMembershipOnConflict `json:"on_conflict,omitempty"`
}

// Boolean expression to filter rows from the table "saas_membership". All fields are combined with a logical 'AND'.
type SaasMembershipBoolExp struct {
	And         []*SaasMembershipBoolExp  `json:"_and,omitempty"`
	Not         *SaasMembershipBoolExp    `json:"_not,omitempty"`
	Or          []*SaasMembershipBoolExp  `json:"_or,omitempty"`
	CreatedAt   *TimestamptzComparisonExp `json:"created_at,omitempty"`
	ID          *UUIDComparisonExp        `json:"id,omitempty"`
	IDAccount   *UUIDComparisonExp        `json:"id_account,omitempty"`
	IDRole      *StringComparisonExp      `json:"id_role,omitempty"`
	IDUser      *StringComparisonExp      `json:"id_user,omitempty"`
	SaasAccount *SaasAccountBoolExp       `json:"saas_account,omitempty"`
	SaasRole    *SaasRoleBoolExp          `json:"saas_role,omitempty"`
	SelectedAt  *TimestamptzComparisonExp `json:"selected_at,omitempty"`
	UpdatedAt   *TimestamptzComparisonExp `json:"updated_at,omitempty"`
}

// input type for inserting data into table "saas_membership"
type SaasMembershipInsertInput struct {
	CreatedAt   *string                       `json:"created_at,omitempty"`
	ID          *string                       `json:"id,omitempty"`
	IDAccount   *string                       `json:"id_account,omitempty"`
	IDRole      *string                       `json:"id_role,omitempty"`
	IDUser      *string                       `json:"id_user,omitempty"`
	SaasAccount *SaasAccountObjRelInsertInput `json:"saas_account,omitempty"`
	SaasRole    *SaasRoleObjRelInsertInput    `json:"saas_role,omitempty"`
	SelectedAt  *string                       `json:"selected_at,omitempty"`
	UpdatedAt   *string                       `json:"updated_at,omitempty"`
}

// aggregate max on columns
type SaasMembershipMaxFields struct {
	CreatedAt  *string `json:"created_at,omitempty"`
	ID         *string `json:"id,omitempty"`
	IDAccount  *string `json:"id_account,omitempty"`
	IDRole     *string `json:"id_role,omitempty"`
	IDUser     *string `json:"id_user,omitempty"`
	SelectedAt *string `json:"selected_at,omitempty"`
	UpdatedAt  *string `json:"updated_at,omitempty"`
}

// order by max() on columns of table "saas_membership"
type SaasMembershipMaxOrderBy struct {
	CreatedAt  *OrderBy `json:"created_at,omitempty"`
	ID         *OrderBy `json:"id,omitempty"`
	IDAccount  *OrderBy `json:"id_account,omitempty"`
	IDRole     *OrderBy `json:"id_role,omitempty"`
	IDUser     *OrderBy `json:"id_user,omitempty"`
	SelectedAt *OrderBy `json:"selected_at,omitempty"`
	UpdatedAt  *OrderBy `json:"updated_at,omitempty"`
}

// aggregate min on columns
type SaasMembershipMinFields struct {
	CreatedAt  *string `json:"created_at,omitempty"`
	ID         *string `json:"id,omitempty"`
	IDAccount  *string `json:"id_account,omitempty"`
	IDRole     *string `json:"id_role,omitempty"`
	IDUser     *string `json:"id_user,omitempty"`
	SelectedAt *string `json:"selected_at,omitempty"`
	UpdatedAt  *string `json:"updated_at,omitempty"`
}

// order by min() on columns of table "saas_membership"
type SaasMembershipMinOrderBy struct {
	CreatedAt  *OrderBy `json:"created_at,omitempty"`
	ID         *OrderBy `json:"id,omitempty"`
	IDAccount  *OrderBy `json:"id_account,omitempty"`
	IDRole     *OrderBy `json:"id_role,omitempty"`
	IDUser     *OrderBy `json:"id_user,omitempty"`
	SelectedAt *OrderBy `json:"selected_at,omitempty"`
	UpdatedAt  *OrderBy `json:"updated_at,omitempty"`
}

// response of any mutation on the table "saas_membership"
type SaasMembershipMutationResponse struct {
	// number of rows affected by the mutation
	AffectedRows int64 `json:"affected_rows"`
	// data from the rows affected by the mutation
	Returning []*SaasMembership `json:"returning,omitempty"`
}

// on conflict condition type for table "saas_membership"
type SaasMembershipOnConflict struct {
	Constraint    SaasMembershipConstraint     `json:"constraint"`
	UpdateColumns []SaasMembershipUpdateColumn `json:"update_columns,omitempty"`
	Where         *SaasMembershipBoolExp       `json:"where,omitempty"`
}

// Ordering options when selecting data from "saas_membership".
type SaasMembershipOrderBy struct {
	CreatedAt   *OrderBy            `json:"created_at,omitempty"`
	ID          *OrderBy            `json:"id,omitempty"`
	IDAccount   *OrderBy            `json:"id_account,omitempty"`
	IDRole      *OrderBy            `json:"id_role,omitempty"`
	IDUser      *OrderBy            `json:"id_user,omitempty"`
	SaasAccount *SaasAccountOrderBy `json:"saas_account,omitempty"`
	SaasRole    *SaasRoleOrderBy    `json:"saas_role,omitempty"`
	SelectedAt  *OrderBy            `json:"selected_at,omitempty"`
	UpdatedAt   *OrderBy            `json:"updated_at,omitempty"`
}

// primary key columns input for table: saas_membership
type SaasMembershipPkColumnsInput struct {
	ID string `json:"id"`
}

// input type for updating data in table "saas_membership"
type SaasMembershipSetInput struct {
	CreatedAt  *string `json:"created_at,omitempty"`
	ID         *string `json:"id,omitempty"`
	IDAccount  *string `json:"id_account,omitempty"`
	IDRole     *string `json:"id_role,omitempty"`
	IDUser     *string `json:"id_user,omitempty"`
	SelectedAt *string `json:"selected_at,omitempty"`
	UpdatedAt  *string `json:"updated_at,omitempty"`
}

// columns and relationships of "saas_role"
type SaasRole struct {
	CreatedAt   string `json:"created_at"`
	Description string `json:"description"`
	ID          string `json:"id"`
	// An array relationship
	SaasMemberships []*SaasMembership `json:"saas_memberships,omitempty"`
	// An aggregate relationship
	SaasMembershipsAggregate *SaasMembershipAggregate `json:"saas_memberships_aggregate,omitempty"`
	UpdatedAt                string                   `json:"updated_at"`
}

// aggregated selection of "saas_role"
type SaasRoleAggregate struct {
	Aggregate *SaasRoleAggregateFields `json:"aggregate,omitempty"`
	Nodes     []*SaasRole              `json:"nodes,omitempty"`
}

// aggregate fields of "saas_role"
type SaasRoleAggregateFields struct {
	Count int64              `json:"count"`
	Max   *SaasRoleMaxFields `json:"max,omitempty"`
	Min   *SaasRoleMinFields `json:"min,omitempty"`
}

// Boolean expression to filter rows from the table "saas_role". All fields are combined with a logical 'AND'.
type SaasRoleBoolExp struct {
	And             []*SaasRoleBoolExp        `json:"_and,omitempty"`
	Not             *SaasRoleBoolExp          `json:"_not,omitempty"`
	Or              []*SaasRoleBoolExp        `json:"_or,omitempty"`
	CreatedAt       *TimestamptzComparisonExp `json:"created_at,omitempty"`
	Description     *StringComparisonExp      `json:"description,omitempty"`
	ID              *StringComparisonExp      `json:"id,omitempty"`
	SaasMemberships *SaasMembershipBoolExp    `json:"saas_memberships,omitempty"`
	UpdatedAt       *TimestamptzComparisonExp `json:"updated_at,omitempty"`
}

// input type for inserting data into table "saas_role"
type SaasRoleInsertInput struct {
	CreatedAt       *string                          `json:"created_at,omitempty"`
	Description     *string                          `json:"description,omitempty"`
	ID              *string                          `json:"id,omitempty"`
	SaasMemberships *SaasMembershipArrRelInsertInput `json:"saas_memberships,omitempty"`
	UpdatedAt       *string                          `json:"updated_at,omitempty"`
}

// aggregate max on columns
type SaasRoleMaxFields struct {
	CreatedAt   *string `json:"created_at,omitempty"`
	Description *string `json:"description,omitempty"`
	ID          *string `json:"id,omitempty"`
	UpdatedAt   *string `json:"updated_at,omitempty"`
}

// aggregate min on columns
type SaasRoleMinFields struct {
	CreatedAt   *string `json:"created_at,omitempty"`
	Description *string `json:"description,omitempty"`
	ID          *string `json:"id,omitempty"`
	UpdatedAt   *string `json:"updated_at,omitempty"`
}

// response of any mutation on the table "saas_role"
type SaasRoleMutationResponse struct {
	// number of rows affected by the mutation
	AffectedRows int64 `json:"affected_rows"`
	// data from the rows affected by the mutation
	Returning []*SaasRole `json:"returning,omitempty"`
}

// input type for inserting object relation for remote table "saas_role"
type SaasRoleObjRelInsertInput struct {
	Data *SaasRoleInsertInput `json:"data,omitempty"`
	// on conflict condition
	OnConflict *SaasRoleOnConflict `json:"on_conflict,omitempty"`
}

// on conflict condition type for table "saas_role"
type SaasRoleOnConflict struct {
	Constraint    SaasRoleConstraint     `json:"constraint"`
	UpdateColumns []SaasRoleUpdateColumn `json:"update_columns,omitempty"`
	Where         *SaasRoleBoolExp       `json:"where,omitempty"`
}

// Ordering options when selecting data from "saas_role".
type SaasRoleOrderBy struct {
	CreatedAt                *OrderBy                        `json:"created_at,omitempty"`
	Description              *OrderBy                        `json:"description,omitempty"`
	ID                       *OrderBy                        `json:"id,omitempty"`
	SaasMembershipsAggregate *SaasMembershipAggregateOrderBy `json:"saas_memberships_aggregate,omitempty"`
	UpdatedAt                *OrderBy                        `json:"updated_at,omitempty"`
}

// primary key columns input for table: saas_role
type SaasRolePkColumnsInput struct {
	ID string `json:"id"`
}

// input type for updating data in table "saas_role"
type SaasRoleSetInput struct {
	CreatedAt   *string `json:"created_at,omitempty"`
	Description *string `json:"description,omitempty"`
	ID          *string `json:"id,omitempty"`
	UpdatedAt   *string `json:"updated_at,omitempty"`
}

// columns and relationships of "saas_user_account"
type SaasUserAccount struct {
	CreatedAt *string `json:"created_at,omitempty"`
	ID        *string `json:"id,omitempty"`
	IDUser    *string `json:"id_user,omitempty"`
	Name      *string `json:"name,omitempty"`
	UpdatedAt *string `json:"updated_at,omitempty"`
}

// aggregated selection of "saas_user_account"
type SaasUserAccountAggregate struct {
	Aggregate *SaasUserAccountAggregateFields `json:"aggregate,omitempty"`
	Nodes     []*SaasUserAccount              `json:"nodes,omitempty"`
}

// aggregate fields of "saas_user_account"
type SaasUserAccountAggregateFields struct {
	Count int64                     `json:"count"`
	Max   *SaasUserAccountMaxFields `json:"max,omitempty"`
	Min   *SaasUserAccountMinFields `json:"min,omitempty"`
}

// Boolean expression to filter rows from the table "saas_user_account". All fields are combined with a logical 'AND'.
type SaasUserAccountBoolExp struct {
	And       []*SaasUserAccountBoolExp `json:"_and,omitempty"`
	Not       *SaasUserAccountBoolExp   `json:"_not,omitempty"`
	Or        []*SaasUserAccountBoolExp `json:"_or,omitempty"`
	CreatedAt *TimestamptzComparisonExp `json:"created_at,omitempty"`
	ID        *UUIDComparisonExp        `json:"id,omitempty"`
	IDUser    *StringComparisonExp      `json:"id_user,omitempty"`
	Name      *StringComparisonExp      `json:"name,omitempty"`
	UpdatedAt *TimestamptzComparisonExp `json:"updated_at,omitempty"`
}

// aggregate max on columns
type SaasUserAccountMaxFields struct {
	CreatedAt *string `json:"created_at,omitempty"`
	ID        *string `json:"id,omitempty"`
	IDUser    *string `json:"id_user,omitempty"`
	Name      *string `json:"name,omitempty"`
	UpdatedAt *string `json:"updated_at,omitempty"`
}

// aggregate min on columns
type SaasUserAccountMinFields struct {
	CreatedAt *string `json:"created_at,omitempty"`
	ID        *string `json:"id,omitempty"`
	IDUser    *string `json:"id_user,omitempty"`
	Name      *string `json:"name,omitempty"`
	UpdatedAt *string `json:"updated_at,omitempty"`
}

// Ordering options when selecting data from "saas_user_account".
type SaasUserAccountOrderBy struct {
	CreatedAt *OrderBy `json:"created_at,omitempty"`
	ID        *OrderBy `json:"id,omitempty"`
	IDUser    *OrderBy `json:"id_user,omitempty"`
	Name      *OrderBy `json:"name,omitempty"`
	UpdatedAt *OrderBy `json:"updated_at,omitempty"`
}

// columns and relationships of "subscription_active_plan"
type SubscriptionActivePlan struct {
	Description *string `json:"description,omitempty"`
	ID          *string `json:"id,omitempty"`
}

// aggregated selection of "subscription_active_plan"
type SubscriptionActivePlanAggregate struct {
	Aggregate *SubscriptionActivePlanAggregateFields `json:"aggregate,omitempty"`
	Nodes     []*SubscriptionActivePlan              `json:"nodes,omitempty"`
}

// aggregate fields of "subscription_active_plan"
type SubscriptionActivePlanAggregateFields struct {
	Count int64                            `json:"count"`
	Max   *SubscriptionActivePlanMaxFields `json:"max,omitempty"`
	Min   *SubscriptionActivePlanMinFields `json:"min,omitempty"`
}

// Boolean expression to filter rows from the table "subscription_active_plan". All fields are combined with a logical 'AND'.
type SubscriptionActivePlanBoolExp struct {
	And         []*SubscriptionActivePlanBoolExp `json:"_and,omitempty"`
	Not         *SubscriptionActivePlanBoolExp   `json:"_not,omitempty"`
	Or          []*SubscriptionActivePlanBoolExp `json:"_or,omitempty"`
	Description *StringComparisonExp             `json:"description,omitempty"`
	ID          *StringComparisonExp             `json:"id,omitempty"`
}

// input type for inserting data into table "subscription_active_plan"
type SubscriptionActivePlanInsertInput struct {
	Description *string `json:"description,omitempty"`
	ID          *string `json:"id,omitempty"`
}

// aggregate max on columns
type SubscriptionActivePlanMaxFields struct {
	Description *string `json:"description,omitempty"`
	ID          *string `json:"id,omitempty"`
}

// aggregate min on columns
type SubscriptionActivePlanMinFields struct {
	Description *string `json:"description,omitempty"`
	ID          *string `json:"id,omitempty"`
}

// response of any mutation on the table "subscription_active_plan"
type SubscriptionActivePlanMutationResponse struct {
	// number of rows affected by the mutation
	AffectedRows int64 `json:"affected_rows"`
	// data from the rows affected by the mutation
	Returning []*SubscriptionActivePlan `json:"returning,omitempty"`
}

// Ordering options when selecting data from "subscription_active_plan".
type SubscriptionActivePlanOrderBy struct {
	Description *OrderBy `json:"description,omitempty"`
	ID          *OrderBy `json:"id,omitempty"`
}

// input type for updating data in table "subscription_active_plan"
type SubscriptionActivePlanSetInput struct {
	Description *string `json:"description,omitempty"`
	ID          *string `json:"id,omitempty"`
}

// columns and relationships of "subscription_customer"
type SubscriptionCustomer struct {
	CreatedAt string `json:"created_at"`
	ID        string `json:"id"`
	IDAccount string `json:"id_account"`
	// An object relationship
	SaasAccount    *SaasAccount `json:"saas_account,omitempty"`
	StripeCustomer string       `json:"stripe_customer"`
	UpdatedAt      string       `json:"updated_at"`
}

// aggregated selection of "subscription_customer"
type SubscriptionCustomerAggregate struct {
	Aggregate *SubscriptionCustomerAggregateFields `json:"aggregate,omitempty"`
	Nodes     []*SubscriptionCustomer              `json:"nodes,omitempty"`
}

// aggregate fields of "subscription_customer"
type SubscriptionCustomerAggregateFields struct {
	Count int64                          `json:"count"`
	Max   *SubscriptionCustomerMaxFields `json:"max,omitempty"`
	Min   *SubscriptionCustomerMinFields `json:"min,omitempty"`
}

// Boolean expression to filter rows from the table "subscription_customer". All fields are combined with a logical 'AND'.
type SubscriptionCustomerBoolExp struct {
	And            []*SubscriptionCustomerBoolExp `json:"_and,omitempty"`
	Not            *SubscriptionCustomerBoolExp   `json:"_not,omitempty"`
	Or             []*SubscriptionCustomerBoolExp `json:"_or,omitempty"`
	CreatedAt      *TimestamptzComparisonExp      `json:"created_at,omitempty"`
	ID             *UUIDComparisonExp             `json:"id,omitempty"`
	IDAccount      *UUIDComparisonExp             `json:"id_account,omitempty"`
	SaasAccount    *SaasAccountBoolExp            `json:"saas_account,omitempty"`
	StripeCustomer *StringComparisonExp           `json:"stripe_customer,omitempty"`
	UpdatedAt      *TimestamptzComparisonExp      `json:"updated_at,omitempty"`
}

// input type for inserting data into table "subscription_customer"
type SubscriptionCustomerInsertInput struct {
	CreatedAt      *string                       `json:"created_at,omitempty"`
	ID             *string                       `json:"id,omitempty"`
	IDAccount      *string                       `json:"id_account,omitempty"`
	SaasAccount    *SaasAccountObjRelInsertInput `json:"saas_account,omitempty"`
	StripeCustomer *string                       `json:"stripe_customer,omitempty"`
	UpdatedAt      *string                       `json:"updated_at,omitempty"`
}

// aggregate max on columns
type SubscriptionCustomerMaxFields struct {
	CreatedAt      *string `json:"created_at,omitempty"`
	ID             *string `json:"id,omitempty"`
	IDAccount      *string `json:"id_account,omitempty"`
	StripeCustomer *string `json:"stripe_customer,omitempty"`
	UpdatedAt      *string `json:"updated_at,omitempty"`
}

// aggregate min on columns
type SubscriptionCustomerMinFields struct {
	CreatedAt      *string `json:"created_at,omitempty"`
	ID             *string `json:"id,omitempty"`
	IDAccount      *string `json:"id_account,omitempty"`
	StripeCustomer *string `json:"stripe_customer,omitempty"`
	UpdatedAt      *string `json:"updated_at,omitempty"`
}

// response of any mutation on the table "subscription_customer"
type SubscriptionCustomerMutationResponse struct {
	// number of rows affected by the mutation
	AffectedRows int64 `json:"affected_rows"`
	// data from the rows affected by the mutation
	Returning []*SubscriptionCustomer `json:"returning,omitempty"`
}

// input type for inserting object relation for remote table "subscription_customer"
type SubscriptionCustomerObjRelInsertInput struct {
	Data *SubscriptionCustomerInsertInput `json:"data,omitempty"`
	// on conflict condition
	OnConflict *SubscriptionCustomerOnConflict `json:"on_conflict,omitempty"`
}

// on conflict condition type for table "subscription_customer"
type SubscriptionCustomerOnConflict struct {
	Constraint    SubscriptionCustomerConstraint     `json:"constraint"`
	UpdateColumns []SubscriptionCustomerUpdateColumn `json:"update_columns,omitempty"`
	Where         *SubscriptionCustomerBoolExp       `json:"where,omitempty"`
}

// Ordering options when selecting data from "subscription_customer".
type SubscriptionCustomerOrderBy struct {
	CreatedAt      *OrderBy            `json:"created_at,omitempty"`
	ID             *OrderBy            `json:"id,omitempty"`
	IDAccount      *OrderBy            `json:"id_account,omitempty"`
	SaasAccount    *SaasAccountOrderBy `json:"saas_account,omitempty"`
	StripeCustomer *OrderBy            `json:"stripe_customer,omitempty"`
	UpdatedAt      *OrderBy            `json:"updated_at,omitempty"`
}

// primary key columns input for table: subscription_customer
type SubscriptionCustomerPkColumnsInput struct {
	ID string `json:"id"`
}

// input type for updating data in table "subscription_customer"
type SubscriptionCustomerSetInput struct {
	CreatedAt      *string `json:"created_at,omitempty"`
	ID             *string `json:"id,omitempty"`
	IDAccount      *string `json:"id_account,omitempty"`
	StripeCustomer *string `json:"stripe_customer,omitempty"`
	UpdatedAt      *string `json:"updated_at,omitempty"`
}

// columns and relationships of "subscription_event"
type SubscriptionEvent struct {
	CreatedAt string                 `json:"created_at"`
	Data      map[string]interface{} `json:"data,omitempty"`
	ID        string                 `json:"id"`
	Type      string                 `json:"type"`
	UpdatedAt string                 `json:"updated_at"`
}

// aggregated selection of "subscription_event"
type SubscriptionEventAggregate struct {
	Aggregate *SubscriptionEventAggregateFields `json:"aggregate,omitempty"`
	Nodes     []*SubscriptionEvent              `json:"nodes,omitempty"`
}

// aggregate fields of "subscription_event"
type SubscriptionEventAggregateFields struct {
	Count int64                       `json:"count"`
	Max   *SubscriptionEventMaxFields `json:"max,omitempty"`
	Min   *SubscriptionEventMinFields `json:"min,omitempty"`
}

// append existing jsonb value of filtered columns with new jsonb value
type SubscriptionEventAppendInput struct {
	Data map[string]interface{} `json:"data,omitempty"`
}

// Boolean expression to filter rows from the table "subscription_event". All fields are combined with a logical 'AND'.
type SubscriptionEventBoolExp struct {
	And       []*SubscriptionEventBoolExp `json:"_and,omitempty"`
	Not       *SubscriptionEventBoolExp   `json:"_not,omitempty"`
	Or        []*SubscriptionEventBoolExp `json:"_or,omitempty"`
	CreatedAt *TimestamptzComparisonExp   `json:"created_at,omitempty"`
	Data      *JsonbComparisonExp         `json:"data,omitempty"`
	ID        *UUIDComparisonExp          `json:"id,omitempty"`
	Type      *StringComparisonExp        `json:"type,omitempty"`
	UpdatedAt *TimestamptzComparisonExp   `json:"updated_at,omitempty"`
}

// delete the field or element with specified path (for JSON arrays, negative integers count from the end)
type SubscriptionEventDeleteAtPathInput struct {
	Data []string `json:"data,omitempty"`
}

// delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
type SubscriptionEventDeleteElemInput struct {
	Data *int64 `json:"data,omitempty"`
}

// delete key/value pair or string element. key/value pairs are matched based on their key value
type SubscriptionEventDeleteKeyInput struct {
	Data *string `json:"data,omitempty"`
}

// input type for inserting data into table "subscription_event"
type SubscriptionEventInsertInput struct {
	CreatedAt *string                `json:"created_at,omitempty"`
	Data      map[string]interface{} `json:"data,omitempty"`
	ID        *string                `json:"id,omitempty"`
	Type      *string                `json:"type,omitempty"`
	UpdatedAt *string                `json:"updated_at,omitempty"`
}

// aggregate max on columns
type SubscriptionEventMaxFields struct {
	CreatedAt *string `json:"created_at,omitempty"`
	ID        *string `json:"id,omitempty"`
	Type      *string `json:"type,omitempty"`
	UpdatedAt *string `json:"updated_at,omitempty"`
}

// aggregate min on columns
type SubscriptionEventMinFields struct {
	CreatedAt *string `json:"created_at,omitempty"`
	ID        *string `json:"id,omitempty"`
	Type      *string `json:"type,omitempty"`
	UpdatedAt *string `json:"updated_at,omitempty"`
}

// response of any mutation on the table "subscription_event"
type SubscriptionEventMutationResponse struct {
	// number of rows affected by the mutation
	AffectedRows int64 `json:"affected_rows"`
	// data from the rows affected by the mutation
	Returning []*SubscriptionEvent `json:"returning,omitempty"`
}

// on conflict condition type for table "subscription_event"
type SubscriptionEventOnConflict struct {
	Constraint    SubscriptionEventConstraint     `json:"constraint"`
	UpdateColumns []SubscriptionEventUpdateColumn `json:"update_columns,omitempty"`
	Where         *SubscriptionEventBoolExp       `json:"where,omitempty"`
}

// Ordering options when selecting data from "subscription_event".
type SubscriptionEventOrderBy struct {
	CreatedAt *OrderBy `json:"created_at,omitempty"`
	Data      *OrderBy `json:"data,omitempty"`
	ID        *OrderBy `json:"id,omitempty"`
	Type      *OrderBy `json:"type,omitempty"`
	UpdatedAt *OrderBy `json:"updated_at,omitempty"`
}

// primary key columns input for table: subscription_event
type SubscriptionEventPkColumnsInput struct {
	ID string `json:"id"`
}

// prepend existing jsonb value of filtered columns with new jsonb value
type SubscriptionEventPrependInput struct {
	Data map[string]interface{} `json:"data,omitempty"`
}

// input type for updating data in table "subscription_event"
type SubscriptionEventSetInput struct {
	CreatedAt *string                `json:"created_at,omitempty"`
	Data      map[string]interface{} `json:"data,omitempty"`
	ID        *string                `json:"id,omitempty"`
	Type      *string                `json:"type,omitempty"`
	UpdatedAt *string                `json:"updated_at,omitempty"`
}

// columns and relationships of "subscription_plan"
type SubscriptionPlan struct {
	CreatedAt   string  `json:"created_at"`
	Description string  `json:"description"`
	ID          string  `json:"id"`
	IsActive    bool    `json:"is_active"`
	StripeCode  *string `json:"stripe_code,omitempty"`
	// An array relationship
	SubscriptionStatuses []*SubscriptionStatus `json:"subscription_statuses,omitempty"`
	// An aggregate relationship
	SubscriptionStatusesAggregate *SubscriptionStatusAggregate `json:"subscription_statuses_aggregate,omitempty"`
	UpdatedAt                     string                       `json:"updated_at"`
}

// aggregated selection of "subscription_plan"
type SubscriptionPlanAggregate struct {
	Aggregate *SubscriptionPlanAggregateFields `json:"aggregate,omitempty"`
	Nodes     []*SubscriptionPlan              `json:"nodes,omitempty"`
}

// aggregate fields of "subscription_plan"
type SubscriptionPlanAggregateFields struct {
	Count int64                      `json:"count"`
	Max   *SubscriptionPlanMaxFields `json:"max,omitempty"`
	Min   *SubscriptionPlanMinFields `json:"min,omitempty"`
}

// Boolean expression to filter rows from the table "subscription_plan". All fields are combined with a logical 'AND'.
type SubscriptionPlanBoolExp struct {
	And                  []*SubscriptionPlanBoolExp `json:"_and,omitempty"`
	Not                  *SubscriptionPlanBoolExp   `json:"_not,omitempty"`
	Or                   []*SubscriptionPlanBoolExp `json:"_or,omitempty"`
	CreatedAt            *TimestamptzComparisonExp  `json:"created_at,omitempty"`
	Description          *StringComparisonExp       `json:"description,omitempty"`
	ID                   *StringComparisonExp       `json:"id,omitempty"`
	IsActive             *BooleanComparisonExp      `json:"is_active,omitempty"`
	StripeCode           *StringComparisonExp       `json:"stripe_code,omitempty"`
	SubscriptionStatuses *SubscriptionStatusBoolExp `json:"subscription_statuses,omitempty"`
	UpdatedAt            *TimestamptzComparisonExp  `json:"updated_at,omitempty"`
}

// input type for inserting data into table "subscription_plan"
type SubscriptionPlanInsertInput struct {
	CreatedAt            *string                              `json:"created_at,omitempty"`
	Description          *string                              `json:"description,omitempty"`
	ID                   *string                              `json:"id,omitempty"`
	IsActive             *bool                                `json:"is_active,omitempty"`
	StripeCode           *string                              `json:"stripe_code,omitempty"`
	SubscriptionStatuses *SubscriptionStatusArrRelInsertInput `json:"subscription_statuses,omitempty"`
	UpdatedAt            *string                              `json:"updated_at,omitempty"`
}

// aggregate max on columns
type SubscriptionPlanMaxFields struct {
	CreatedAt   *string `json:"created_at,omitempty"`
	Description *string `json:"description,omitempty"`
	ID          *string `json:"id,omitempty"`
	StripeCode  *string `json:"stripe_code,omitempty"`
	UpdatedAt   *string `json:"updated_at,omitempty"`
}

// aggregate min on columns
type SubscriptionPlanMinFields struct {
	CreatedAt   *string `json:"created_at,omitempty"`
	Description *string `json:"description,omitempty"`
	ID          *string `json:"id,omitempty"`
	StripeCode  *string `json:"stripe_code,omitempty"`
	UpdatedAt   *string `json:"updated_at,omitempty"`
}

// response of any mutation on the table "subscription_plan"
type SubscriptionPlanMutationResponse struct {
	// number of rows affected by the mutation
	AffectedRows int64 `json:"affected_rows"`
	// data from the rows affected by the mutation
	Returning []*SubscriptionPlan `json:"returning,omitempty"`
}

// input type for inserting object relation for remote table "subscription_plan"
type SubscriptionPlanObjRelInsertInput struct {
	Data *SubscriptionPlanInsertInput `json:"data,omitempty"`
	// on conflict condition
	OnConflict *SubscriptionPlanOnConflict `json:"on_conflict,omitempty"`
}

// on conflict condition type for table "subscription_plan"
type SubscriptionPlanOnConflict struct {
	Constraint    SubscriptionPlanConstraint     `json:"constraint"`
	UpdateColumns []SubscriptionPlanUpdateColumn `json:"update_columns,omitempty"`
	Where         *SubscriptionPlanBoolExp       `json:"where,omitempty"`
}

// Ordering options when selecting data from "subscription_plan".
type SubscriptionPlanOrderBy struct {
	CreatedAt                     *OrderBy                            `json:"created_at,omitempty"`
	Description                   *OrderBy                            `json:"description,omitempty"`
	ID                            *OrderBy                            `json:"id,omitempty"`
	IsActive                      *OrderBy                            `json:"is_active,omitempty"`
	StripeCode                    *OrderBy                            `json:"stripe_code,omitempty"`
	SubscriptionStatusesAggregate *SubscriptionStatusAggregateOrderBy `json:"subscription_statuses_aggregate,omitempty"`
	UpdatedAt                     *OrderBy                            `json:"updated_at,omitempty"`
}

// primary key columns input for table: subscription_plan
type SubscriptionPlanPkColumnsInput struct {
	ID string `json:"id"`
}

// input type for updating data in table "subscription_plan"
type SubscriptionPlanSetInput struct {
	CreatedAt   *string `json:"created_at,omitempty"`
	Description *string `json:"description,omitempty"`
	ID          *string `json:"id,omitempty"`
	IsActive    *bool   `json:"is_active,omitempty"`
	StripeCode  *string `json:"stripe_code,omitempty"`
	UpdatedAt   *string `json:"updated_at,omitempty"`
}

type SubscriptionRoot struct {
	// fetch data from the table: "saas_account"
	SaasAccount []*SaasAccount `json:"saas_account,omitempty"`
	// fetch aggregated fields from the table: "saas_account"
	SaasAccountAggregate *SaasAccountAggregate `json:"saas_account_aggregate,omitempty"`
	// fetch data from the table: "saas_account" using primary key columns
	SaasAccountByPk *SaasAccount `json:"saas_account_by_pk,omitempty"`
	// fetch data from the table: "saas_address"
	SaasAddress []*SaasAddress `json:"saas_address,omitempty"`
	// fetch aggregated fields from the table: "saas_address"
	SaasAddressAggregate *SaasAddressAggregate `json:"saas_address_aggregate,omitempty"`
	// fetch data from the table: "saas_address" using primary key columns
	SaasAddressByPk *SaasAddress `json:"saas_address_by_pk,omitempty"`
	// fetch data from the table: "saas_membership"
	SaasMembership []*SaasMembership `json:"saas_membership,omitempty"`
	// fetch aggregated fields from the table: "saas_membership"
	SaasMembershipAggregate *SaasMembershipAggregate `json:"saas_membership_aggregate,omitempty"`
	// fetch data from the table: "saas_membership" using primary key columns
	SaasMembershipByPk *SaasMembership `json:"saas_membership_by_pk,omitempty"`
	// fetch data from the table: "saas_role"
	SaasRole []*SaasRole `json:"saas_role,omitempty"`
	// fetch aggregated fields from the table: "saas_role"
	SaasRoleAggregate *SaasRoleAggregate `json:"saas_role_aggregate,omitempty"`
	// fetch data from the table: "saas_role" using primary key columns
	SaasRoleByPk *SaasRole `json:"saas_role_by_pk,omitempty"`
	// fetch data from the table: "saas_user_account"
	SaasUserAccount []*SaasUserAccount `json:"saas_user_account,omitempty"`
	// fetch aggregated fields from the table: "saas_user_account"
	SaasUserAccountAggregate *SaasUserAccountAggregate `json:"saas_user_account_aggregate,omitempty"`
	// fetch data from the table: "subscription_active_plan"
	SubscriptionActivePlan []*SubscriptionActivePlan `json:"subscription_active_plan,omitempty"`
	// fetch aggregated fields from the table: "subscription_active_plan"
	SubscriptionActivePlanAggregate *SubscriptionActivePlanAggregate `json:"subscription_active_plan_aggregate,omitempty"`
	// fetch data from the table: "subscription_customer"
	SubscriptionCustomer []*SubscriptionCustomer `json:"subscription_customer,omitempty"`
	// fetch aggregated fields from the table: "subscription_customer"
	SubscriptionCustomerAggregate *SubscriptionCustomerAggregate `json:"subscription_customer_aggregate,omitempty"`
	// fetch data from the table: "subscription_customer" using primary key columns
	SubscriptionCustomerByPk *SubscriptionCustomer `json:"subscription_customer_by_pk,omitempty"`
	// fetch data from the table: "subscription_event"
	SubscriptionEvent []*SubscriptionEvent `json:"subscription_event,omitempty"`
	// fetch aggregated fields from the table: "subscription_event"
	SubscriptionEventAggregate *SubscriptionEventAggregate `json:"subscription_event_aggregate,omitempty"`
	// fetch data from the table: "subscription_event" using primary key columns
	SubscriptionEventByPk *SubscriptionEvent `json:"subscription_event_by_pk,omitempty"`
	// fetch data from the table: "subscription_plan"
	SubscriptionPlan []*SubscriptionPlan `json:"subscription_plan,omitempty"`
	// fetch aggregated fields from the table: "subscription_plan"
	SubscriptionPlanAggregate *SubscriptionPlanAggregate `json:"subscription_plan_aggregate,omitempty"`
	// fetch data from the table: "subscription_plan" using primary key columns
	SubscriptionPlanByPk *SubscriptionPlan `json:"subscription_plan_by_pk,omitempty"`
	// fetch data from the table: "subscription_status"
	SubscriptionStatus []*SubscriptionStatus `json:"subscription_status,omitempty"`
	// fetch aggregated fields from the table: "subscription_status"
	SubscriptionStatusAggregate *SubscriptionStatusAggregate `json:"subscription_status_aggregate,omitempty"`
	// fetch data from the table: "subscription_status" using primary key columns
	SubscriptionStatusByPk *SubscriptionStatus `json:"subscription_status_by_pk,omitempty"`
}

// columns and relationships of "subscription_status"
type SubscriptionStatus struct {
	CreatedAt string `json:"created_at"`
	ID        string `json:"id"`
	IDAccount string `json:"id_account"`
	IDPlan    string `json:"id_plan"`
	IsActive  bool   `json:"is_active"`
	// An object relationship
	SaasAccount          *SaasAccount `json:"saas_account,omitempty"`
	Status               string       `json:"status"`
	StripeSubscriptionID *string      `json:"stripe_subscription_id,omitempty"`
	// An object relationship
	SubscriptionPlan *SubscriptionPlan `json:"subscription_plan,omitempty"`
	UpdatedAt        string            `json:"updated_at"`
}

// aggregated selection of "subscription_status"
type SubscriptionStatusAggregate struct {
	Aggregate *SubscriptionStatusAggregateFields `json:"aggregate,omitempty"`
	Nodes     []*SubscriptionStatus              `json:"nodes,omitempty"`
}

// aggregate fields of "subscription_status"
type SubscriptionStatusAggregateFields struct {
	Count int64                        `json:"count"`
	Max   *SubscriptionStatusMaxFields `json:"max,omitempty"`
	Min   *SubscriptionStatusMinFields `json:"min,omitempty"`
}

// order by aggregate values of table "subscription_status"
type SubscriptionStatusAggregateOrderBy struct {
	Count *OrderBy                      `json:"count,omitempty"`
	Max   *SubscriptionStatusMaxOrderBy `json:"max,omitempty"`
	Min   *SubscriptionStatusMinOrderBy `json:"min,omitempty"`
}

// input type for inserting array relation for remote table "subscription_status"
type SubscriptionStatusArrRelInsertInput struct {
	Data []*SubscriptionStatusInsertInput `json:"data,omitempty"`
	// on conflict condition
	OnConflict *SubscriptionStatusOnConflict `json:"on_conflict,omitempty"`
}

// Boolean expression to filter rows from the table "subscription_status". All fields are combined with a logical 'AND'.
type SubscriptionStatusBoolExp struct {
	And                  []*SubscriptionStatusBoolExp `json:"_and,omitempty"`
	Not                  *SubscriptionStatusBoolExp   `json:"_not,omitempty"`
	Or                   []*SubscriptionStatusBoolExp `json:"_or,omitempty"`
	CreatedAt            *TimestamptzComparisonExp    `json:"created_at,omitempty"`
	ID                   *UUIDComparisonExp           `json:"id,omitempty"`
	IDAccount            *UUIDComparisonExp           `json:"id_account,omitempty"`
	IDPlan               *StringComparisonExp         `json:"id_plan,omitempty"`
	IsActive             *BooleanComparisonExp        `json:"is_active,omitempty"`
	SaasAccount          *SaasAccountBoolExp          `json:"saas_account,omitempty"`
	Status               *StringComparisonExp         `json:"status,omitempty"`
	StripeSubscriptionID *StringComparisonExp         `json:"stripe_subscription_id,omitempty"`
	SubscriptionPlan     *SubscriptionPlanBoolExp     `json:"subscription_plan,omitempty"`
	UpdatedAt            *TimestamptzComparisonExp    `json:"updated_at,omitempty"`
}

// input type for inserting data into table "subscription_status"
type SubscriptionStatusInsertInput struct {
	CreatedAt            *string                            `json:"created_at,omitempty"`
	ID                   *string                            `json:"id,omitempty"`
	IDAccount            *string                            `json:"id_account,omitempty"`
	IDPlan               *string                            `json:"id_plan,omitempty"`
	IsActive             *bool                              `json:"is_active,omitempty"`
	SaasAccount          *SaasAccountObjRelInsertInput      `json:"saas_account,omitempty"`
	Status               *string                            `json:"status,omitempty"`
	StripeSubscriptionID *string                            `json:"stripe_subscription_id,omitempty"`
	SubscriptionPlan     *SubscriptionPlanObjRelInsertInput `json:"subscription_plan,omitempty"`
	UpdatedAt            *string                            `json:"updated_at,omitempty"`
}

// aggregate max on columns
type SubscriptionStatusMaxFields struct {
	CreatedAt            *string `json:"created_at,omitempty"`
	ID                   *string `json:"id,omitempty"`
	IDAccount            *string `json:"id_account,omitempty"`
	IDPlan               *string `json:"id_plan,omitempty"`
	Status               *string `json:"status,omitempty"`
	StripeSubscriptionID *string `json:"stripe_subscription_id,omitempty"`
	UpdatedAt            *string `json:"updated_at,omitempty"`
}

// order by max() on columns of table "subscription_status"
type SubscriptionStatusMaxOrderBy struct {
	CreatedAt            *OrderBy `json:"created_at,omitempty"`
	ID                   *OrderBy `json:"id,omitempty"`
	IDAccount            *OrderBy `json:"id_account,omitempty"`
	IDPlan               *OrderBy `json:"id_plan,omitempty"`
	Status               *OrderBy `json:"status,omitempty"`
	StripeSubscriptionID *OrderBy `json:"stripe_subscription_id,omitempty"`
	UpdatedAt            *OrderBy `json:"updated_at,omitempty"`
}

// aggregate min on columns
type SubscriptionStatusMinFields struct {
	CreatedAt            *string `json:"created_at,omitempty"`
	ID                   *string `json:"id,omitempty"`
	IDAccount            *string `json:"id_account,omitempty"`
	IDPlan               *string `json:"id_plan,omitempty"`
	Status               *string `json:"status,omitempty"`
	StripeSubscriptionID *string `json:"stripe_subscription_id,omitempty"`
	UpdatedAt            *string `json:"updated_at,omitempty"`
}

// order by min() on columns of table "subscription_status"
type SubscriptionStatusMinOrderBy struct {
	CreatedAt            *OrderBy `json:"created_at,omitempty"`
	ID                   *OrderBy `json:"id,omitempty"`
	IDAccount            *OrderBy `json:"id_account,omitempty"`
	IDPlan               *OrderBy `json:"id_plan,omitempty"`
	Status               *OrderBy `json:"status,omitempty"`
	StripeSubscriptionID *OrderBy `json:"stripe_subscription_id,omitempty"`
	UpdatedAt            *OrderBy `json:"updated_at,omitempty"`
}

// response of any mutation on the table "subscription_status"
type SubscriptionStatusMutationResponse struct {
	// number of rows affected by the mutation
	AffectedRows int64 `json:"affected_rows"`
	// data from the rows affected by the mutation
	Returning []*SubscriptionStatus `json:"returning,omitempty"`
}

// input type for inserting object relation for remote table "subscription_status"
type SubscriptionStatusObjRelInsertInput struct {
	Data *SubscriptionStatusInsertInput `json:"data,omitempty"`
	// on conflict condition
	OnConflict *SubscriptionStatusOnConflict `json:"on_conflict,omitempty"`
}

// on conflict condition type for table "subscription_status"
type SubscriptionStatusOnConflict struct {
	Constraint    SubscriptionStatusConstraint     `json:"constraint"`
	UpdateColumns []SubscriptionStatusUpdateColumn `json:"update_columns,omitempty"`
	Where         *SubscriptionStatusBoolExp       `json:"where,omitempty"`
}

// Ordering options when selecting data from "subscription_status".
type SubscriptionStatusOrderBy struct {
	CreatedAt            *OrderBy                 `json:"created_at,omitempty"`
	ID                   *OrderBy                 `json:"id,omitempty"`
	IDAccount            *OrderBy                 `json:"id_account,omitempty"`
	IDPlan               *OrderBy                 `json:"id_plan,omitempty"`
	IsActive             *OrderBy                 `json:"is_active,omitempty"`
	SaasAccount          *SaasAccountOrderBy      `json:"saas_account,omitempty"`
	Status               *OrderBy                 `json:"status,omitempty"`
	StripeSubscriptionID *OrderBy                 `json:"stripe_subscription_id,omitempty"`
	SubscriptionPlan     *SubscriptionPlanOrderBy `json:"subscription_plan,omitempty"`
	UpdatedAt            *OrderBy                 `json:"updated_at,omitempty"`
}

// primary key columns input for table: subscription_status
type SubscriptionStatusPkColumnsInput struct {
	ID string `json:"id"`
}

// input type for updating data in table "subscription_status"
type SubscriptionStatusSetInput struct {
	CreatedAt            *string `json:"created_at,omitempty"`
	ID                   *string `json:"id,omitempty"`
	IDAccount            *string `json:"id_account,omitempty"`
	IDPlan               *string `json:"id_plan,omitempty"`
	IsActive             *bool   `json:"is_active,omitempty"`
	Status               *string `json:"status,omitempty"`
	StripeSubscriptionID *string `json:"stripe_subscription_id,omitempty"`
	UpdatedAt            *string `json:"updated_at,omitempty"`
}

// Boolean expression to compare columns of type "timestamptz". All fields are combined with logical 'AND'.
type TimestamptzComparisonExp struct {
	Eq     *string  `json:"_eq,omitempty"`
	Gt     *string  `json:"_gt,omitempty"`
	Gte    *string  `json:"_gte,omitempty"`
	In     []string `json:"_in,omitempty"`
	IsNull *bool    `json:"_is_null,omitempty"`
	Lt     *string  `json:"_lt,omitempty"`
	Lte    *string  `json:"_lte,omitempty"`
	Neq    *string  `json:"_neq,omitempty"`
	Nin    []string `json:"_nin,omitempty"`
}

// Boolean expression to compare columns of type "uuid". All fields are combined with logical 'AND'.
type UUIDComparisonExp struct {
	Eq     *string  `json:"_eq,omitempty"`
	Gt     *string  `json:"_gt,omitempty"`
	Gte    *string  `json:"_gte,omitempty"`
	In     []string `json:"_in,omitempty"`
	IsNull *bool    `json:"_is_null,omitempty"`
	Lt     *string  `json:"_lt,omitempty"`
	Lte    *string  `json:"_lte,omitempty"`
	Neq    *string  `json:"_neq,omitempty"`
	Nin    []string `json:"_nin,omitempty"`
}

// column ordering options
type OrderBy string

const (
	// in ascending order, nulls last
	OrderByAsc OrderBy = "asc"
	// in ascending order, nulls first
	OrderByAscNullsFirst OrderBy = "asc_nulls_first"
	// in ascending order, nulls last
	OrderByAscNullsLast OrderBy = "asc_nulls_last"
	// in descending order, nulls first
	OrderByDesc OrderBy = "desc"
	// in descending order, nulls first
	OrderByDescNullsFirst OrderBy = "desc_nulls_first"
	// in descending order, nulls last
	OrderByDescNullsLast OrderBy = "desc_nulls_last"
)

var AllOrderBy = []OrderBy{
	OrderByAsc,
	OrderByAscNullsFirst,
	OrderByAscNullsLast,
	OrderByDesc,
	OrderByDescNullsFirst,
	OrderByDescNullsLast,
}

func (e OrderBy) IsValid() bool {
	switch e {
	case OrderByAsc, OrderByAscNullsFirst, OrderByAscNullsLast, OrderByDesc, OrderByDescNullsFirst, OrderByDescNullsLast:
		return true
	}
	return false
}

func (e OrderBy) String() string {
	return string(e)
}

func (e *OrderBy) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = OrderBy(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid order_by", str)
	}
	return nil
}

func (e OrderBy) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// unique or primary key constraints on table "saas_account"
type SaasAccountConstraint string

const (
	// unique or primary key constraint
	SaasAccountConstraintSaasAccountNameKey SaasAccountConstraint = "saas_account_name_key"
	// unique or primary key constraint
	SaasAccountConstraintSaasAccountPkey SaasAccountConstraint = "saas_account_pkey"
)

var AllSaasAccountConstraint = []SaasAccountConstraint{
	SaasAccountConstraintSaasAccountNameKey,
	SaasAccountConstraintSaasAccountPkey,
}

func (e SaasAccountConstraint) IsValid() bool {
	switch e {
	case SaasAccountConstraintSaasAccountNameKey, SaasAccountConstraintSaasAccountPkey:
		return true
	}
	return false
}

func (e SaasAccountConstraint) String() string {
	return string(e)
}

func (e *SaasAccountConstraint) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = SaasAccountConstraint(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid saas_account_constraint", str)
	}
	return nil
}

func (e SaasAccountConstraint) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// select columns of table "saas_account"
type SaasAccountSelectColumn string

const (
	// column name
	SaasAccountSelectColumnCreatedAt SaasAccountSelectColumn = "created_at"
	// column name
	SaasAccountSelectColumnID SaasAccountSelectColumn = "id"
	// column name
	SaasAccountSelectColumnIDAddressInvoice SaasAccountSelectColumn = "id_address_invoice"
	// column name
	SaasAccountSelectColumnName SaasAccountSelectColumn = "name"
	// column name
	SaasAccountSelectColumnUpdatedAt SaasAccountSelectColumn = "updated_at"
)

var AllSaasAccountSelectColumn = []SaasAccountSelectColumn{
	SaasAccountSelectColumnCreatedAt,
	SaasAccountSelectColumnID,
	SaasAccountSelectColumnIDAddressInvoice,
	SaasAccountSelectColumnName,
	SaasAccountSelectColumnUpdatedAt,
}

func (e SaasAccountSelectColumn) IsValid() bool {
	switch e {
	case SaasAccountSelectColumnCreatedAt, SaasAccountSelectColumnID, SaasAccountSelectColumnIDAddressInvoice, SaasAccountSelectColumnName, SaasAccountSelectColumnUpdatedAt:
		return true
	}
	return false
}

func (e SaasAccountSelectColumn) String() string {
	return string(e)
}

func (e *SaasAccountSelectColumn) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = SaasAccountSelectColumn(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid saas_account_select_column", str)
	}
	return nil
}

func (e SaasAccountSelectColumn) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// update columns of table "saas_account"
type SaasAccountUpdateColumn string

const (
	// column name
	SaasAccountUpdateColumnCreatedAt SaasAccountUpdateColumn = "created_at"
	// column name
	SaasAccountUpdateColumnID SaasAccountUpdateColumn = "id"
	// column name
	SaasAccountUpdateColumnIDAddressInvoice SaasAccountUpdateColumn = "id_address_invoice"
	// column name
	SaasAccountUpdateColumnName SaasAccountUpdateColumn = "name"
	// column name
	SaasAccountUpdateColumnUpdatedAt SaasAccountUpdateColumn = "updated_at"
)

var AllSaasAccountUpdateColumn = []SaasAccountUpdateColumn{
	SaasAccountUpdateColumnCreatedAt,
	SaasAccountUpdateColumnID,
	SaasAccountUpdateColumnIDAddressInvoice,
	SaasAccountUpdateColumnName,
	SaasAccountUpdateColumnUpdatedAt,
}

func (e SaasAccountUpdateColumn) IsValid() bool {
	switch e {
	case SaasAccountUpdateColumnCreatedAt, SaasAccountUpdateColumnID, SaasAccountUpdateColumnIDAddressInvoice, SaasAccountUpdateColumnName, SaasAccountUpdateColumnUpdatedAt:
		return true
	}
	return false
}

func (e SaasAccountUpdateColumn) String() string {
	return string(e)
}

func (e *SaasAccountUpdateColumn) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = SaasAccountUpdateColumn(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid saas_account_update_column", str)
	}
	return nil
}

func (e SaasAccountUpdateColumn) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// unique or primary key constraints on table "saas_address"
type SaasAddressConstraint string

const (
	// unique or primary key constraint
	SaasAddressConstraintSaasAddressPkey SaasAddressConstraint = "saas_address_pkey"
)

var AllSaasAddressConstraint = []SaasAddressConstraint{
	SaasAddressConstraintSaasAddressPkey,
}

func (e SaasAddressConstraint) IsValid() bool {
	switch e {
	case SaasAddressConstraintSaasAddressPkey:
		return true
	}
	return false
}

func (e SaasAddressConstraint) String() string {
	return string(e)
}

func (e *SaasAddressConstraint) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = SaasAddressConstraint(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid saas_address_constraint", str)
	}
	return nil
}

func (e SaasAddressConstraint) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// select columns of table "saas_address"
type SaasAddressSelectColumn string

const (
	// column name
	SaasAddressSelectColumnAddress SaasAddressSelectColumn = "address"
	// column name
	SaasAddressSelectColumnCity SaasAddressSelectColumn = "city"
	// column name
	SaasAddressSelectColumnCountry SaasAddressSelectColumn = "country"
	// column name
	SaasAddressSelectColumnCreatedAt SaasAddressSelectColumn = "created_at"
	// column name
	SaasAddressSelectColumnID SaasAddressSelectColumn = "id"
	// column name
	SaasAddressSelectColumnIDAccount SaasAddressSelectColumn = "id_account"
	// column name
	SaasAddressSelectColumnIDUser SaasAddressSelectColumn = "id_user"
	// column name
	SaasAddressSelectColumnPostalCode SaasAddressSelectColumn = "postal_code"
	// column name
	SaasAddressSelectColumnUpdatedAt SaasAddressSelectColumn = "updated_at"
)

var AllSaasAddressSelectColumn = []SaasAddressSelectColumn{
	SaasAddressSelectColumnAddress,
	SaasAddressSelectColumnCity,
	SaasAddressSelectColumnCountry,
	SaasAddressSelectColumnCreatedAt,
	SaasAddressSelectColumnID,
	SaasAddressSelectColumnIDAccount,
	SaasAddressSelectColumnIDUser,
	SaasAddressSelectColumnPostalCode,
	SaasAddressSelectColumnUpdatedAt,
}

func (e SaasAddressSelectColumn) IsValid() bool {
	switch e {
	case SaasAddressSelectColumnAddress, SaasAddressSelectColumnCity, SaasAddressSelectColumnCountry, SaasAddressSelectColumnCreatedAt, SaasAddressSelectColumnID, SaasAddressSelectColumnIDAccount, SaasAddressSelectColumnIDUser, SaasAddressSelectColumnPostalCode, SaasAddressSelectColumnUpdatedAt:
		return true
	}
	return false
}

func (e SaasAddressSelectColumn) String() string {
	return string(e)
}

func (e *SaasAddressSelectColumn) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = SaasAddressSelectColumn(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid saas_address_select_column", str)
	}
	return nil
}

func (e SaasAddressSelectColumn) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// update columns of table "saas_address"
type SaasAddressUpdateColumn string

const (
	// column name
	SaasAddressUpdateColumnAddress SaasAddressUpdateColumn = "address"
	// column name
	SaasAddressUpdateColumnCity SaasAddressUpdateColumn = "city"
	// column name
	SaasAddressUpdateColumnCountry SaasAddressUpdateColumn = "country"
	// column name
	SaasAddressUpdateColumnCreatedAt SaasAddressUpdateColumn = "created_at"
	// column name
	SaasAddressUpdateColumnID SaasAddressUpdateColumn = "id"
	// column name
	SaasAddressUpdateColumnIDAccount SaasAddressUpdateColumn = "id_account"
	// column name
	SaasAddressUpdateColumnIDUser SaasAddressUpdateColumn = "id_user"
	// column name
	SaasAddressUpdateColumnPostalCode SaasAddressUpdateColumn = "postal_code"
	// column name
	SaasAddressUpdateColumnUpdatedAt SaasAddressUpdateColumn = "updated_at"
)

var AllSaasAddressUpdateColumn = []SaasAddressUpdateColumn{
	SaasAddressUpdateColumnAddress,
	SaasAddressUpdateColumnCity,
	SaasAddressUpdateColumnCountry,
	SaasAddressUpdateColumnCreatedAt,
	SaasAddressUpdateColumnID,
	SaasAddressUpdateColumnIDAccount,
	SaasAddressUpdateColumnIDUser,
	SaasAddressUpdateColumnPostalCode,
	SaasAddressUpdateColumnUpdatedAt,
}

func (e SaasAddressUpdateColumn) IsValid() bool {
	switch e {
	case SaasAddressUpdateColumnAddress, SaasAddressUpdateColumnCity, SaasAddressUpdateColumnCountry, SaasAddressUpdateColumnCreatedAt, SaasAddressUpdateColumnID, SaasAddressUpdateColumnIDAccount, SaasAddressUpdateColumnIDUser, SaasAddressUpdateColumnPostalCode, SaasAddressUpdateColumnUpdatedAt:
		return true
	}
	return false
}

func (e SaasAddressUpdateColumn) String() string {
	return string(e)
}

func (e *SaasAddressUpdateColumn) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = SaasAddressUpdateColumn(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid saas_address_update_column", str)
	}
	return nil
}

func (e SaasAddressUpdateColumn) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// unique or primary key constraints on table "saas_membership"
type SaasMembershipConstraint string

const (
	// unique or primary key constraint
	SaasMembershipConstraintSaasMembershipIDAccountIDUserKey SaasMembershipConstraint = "saas_membership_id_account_id_user_key"
	// unique or primary key constraint
	SaasMembershipConstraintSaasMembershipPkey SaasMembershipConstraint = "saas_membership_pkey"
)

var AllSaasMembershipConstraint = []SaasMembershipConstraint{
	SaasMembershipConstraintSaasMembershipIDAccountIDUserKey,
	SaasMembershipConstraintSaasMembershipPkey,
}

func (e SaasMembershipConstraint) IsValid() bool {
	switch e {
	case SaasMembershipConstraintSaasMembershipIDAccountIDUserKey, SaasMembershipConstraintSaasMembershipPkey:
		return true
	}
	return false
}

func (e SaasMembershipConstraint) String() string {
	return string(e)
}

func (e *SaasMembershipConstraint) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = SaasMembershipConstraint(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid saas_membership_constraint", str)
	}
	return nil
}

func (e SaasMembershipConstraint) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// select columns of table "saas_membership"
type SaasMembershipSelectColumn string

const (
	// column name
	SaasMembershipSelectColumnCreatedAt SaasMembershipSelectColumn = "created_at"
	// column name
	SaasMembershipSelectColumnID SaasMembershipSelectColumn = "id"
	// column name
	SaasMembershipSelectColumnIDAccount SaasMembershipSelectColumn = "id_account"
	// column name
	SaasMembershipSelectColumnIDRole SaasMembershipSelectColumn = "id_role"
	// column name
	SaasMembershipSelectColumnIDUser SaasMembershipSelectColumn = "id_user"
	// column name
	SaasMembershipSelectColumnSelectedAt SaasMembershipSelectColumn = "selected_at"
	// column name
	SaasMembershipSelectColumnUpdatedAt SaasMembershipSelectColumn = "updated_at"
)

var AllSaasMembershipSelectColumn = []SaasMembershipSelectColumn{
	SaasMembershipSelectColumnCreatedAt,
	SaasMembershipSelectColumnID,
	SaasMembershipSelectColumnIDAccount,
	SaasMembershipSelectColumnIDRole,
	SaasMembershipSelectColumnIDUser,
	SaasMembershipSelectColumnSelectedAt,
	SaasMembershipSelectColumnUpdatedAt,
}

func (e SaasMembershipSelectColumn) IsValid() bool {
	switch e {
	case SaasMembershipSelectColumnCreatedAt, SaasMembershipSelectColumnID, SaasMembershipSelectColumnIDAccount, SaasMembershipSelectColumnIDRole, SaasMembershipSelectColumnIDUser, SaasMembershipSelectColumnSelectedAt, SaasMembershipSelectColumnUpdatedAt:
		return true
	}
	return false
}

func (e SaasMembershipSelectColumn) String() string {
	return string(e)
}

func (e *SaasMembershipSelectColumn) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = SaasMembershipSelectColumn(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid saas_membership_select_column", str)
	}
	return nil
}

func (e SaasMembershipSelectColumn) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// update columns of table "saas_membership"
type SaasMembershipUpdateColumn string

const (
	// column name
	SaasMembershipUpdateColumnCreatedAt SaasMembershipUpdateColumn = "created_at"
	// column name
	SaasMembershipUpdateColumnID SaasMembershipUpdateColumn = "id"
	// column name
	SaasMembershipUpdateColumnIDAccount SaasMembershipUpdateColumn = "id_account"
	// column name
	SaasMembershipUpdateColumnIDRole SaasMembershipUpdateColumn = "id_role"
	// column name
	SaasMembershipUpdateColumnIDUser SaasMembershipUpdateColumn = "id_user"
	// column name
	SaasMembershipUpdateColumnSelectedAt SaasMembershipUpdateColumn = "selected_at"
	// column name
	SaasMembershipUpdateColumnUpdatedAt SaasMembershipUpdateColumn = "updated_at"
)

var AllSaasMembershipUpdateColumn = []SaasMembershipUpdateColumn{
	SaasMembershipUpdateColumnCreatedAt,
	SaasMembershipUpdateColumnID,
	SaasMembershipUpdateColumnIDAccount,
	SaasMembershipUpdateColumnIDRole,
	SaasMembershipUpdateColumnIDUser,
	SaasMembershipUpdateColumnSelectedAt,
	SaasMembershipUpdateColumnUpdatedAt,
}

func (e SaasMembershipUpdateColumn) IsValid() bool {
	switch e {
	case SaasMembershipUpdateColumnCreatedAt, SaasMembershipUpdateColumnID, SaasMembershipUpdateColumnIDAccount, SaasMembershipUpdateColumnIDRole, SaasMembershipUpdateColumnIDUser, SaasMembershipUpdateColumnSelectedAt, SaasMembershipUpdateColumnUpdatedAt:
		return true
	}
	return false
}

func (e SaasMembershipUpdateColumn) String() string {
	return string(e)
}

func (e *SaasMembershipUpdateColumn) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = SaasMembershipUpdateColumn(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid saas_membership_update_column", str)
	}
	return nil
}

func (e SaasMembershipUpdateColumn) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// unique or primary key constraints on table "saas_role"
type SaasRoleConstraint string

const (
	// unique or primary key constraint
	SaasRoleConstraintSaasRolePkey SaasRoleConstraint = "saas_role_pkey"
)

var AllSaasRoleConstraint = []SaasRoleConstraint{
	SaasRoleConstraintSaasRolePkey,
}

func (e SaasRoleConstraint) IsValid() bool {
	switch e {
	case SaasRoleConstraintSaasRolePkey:
		return true
	}
	return false
}

func (e SaasRoleConstraint) String() string {
	return string(e)
}

func (e *SaasRoleConstraint) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = SaasRoleConstraint(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid saas_role_constraint", str)
	}
	return nil
}

func (e SaasRoleConstraint) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// select columns of table "saas_role"
type SaasRoleSelectColumn string

const (
	// column name
	SaasRoleSelectColumnCreatedAt SaasRoleSelectColumn = "created_at"
	// column name
	SaasRoleSelectColumnDescription SaasRoleSelectColumn = "description"
	// column name
	SaasRoleSelectColumnID SaasRoleSelectColumn = "id"
	// column name
	SaasRoleSelectColumnUpdatedAt SaasRoleSelectColumn = "updated_at"
)

var AllSaasRoleSelectColumn = []SaasRoleSelectColumn{
	SaasRoleSelectColumnCreatedAt,
	SaasRoleSelectColumnDescription,
	SaasRoleSelectColumnID,
	SaasRoleSelectColumnUpdatedAt,
}

func (e SaasRoleSelectColumn) IsValid() bool {
	switch e {
	case SaasRoleSelectColumnCreatedAt, SaasRoleSelectColumnDescription, SaasRoleSelectColumnID, SaasRoleSelectColumnUpdatedAt:
		return true
	}
	return false
}

func (e SaasRoleSelectColumn) String() string {
	return string(e)
}

func (e *SaasRoleSelectColumn) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = SaasRoleSelectColumn(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid saas_role_select_column", str)
	}
	return nil
}

func (e SaasRoleSelectColumn) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// update columns of table "saas_role"
type SaasRoleUpdateColumn string

const (
	// column name
	SaasRoleUpdateColumnCreatedAt SaasRoleUpdateColumn = "created_at"
	// column name
	SaasRoleUpdateColumnDescription SaasRoleUpdateColumn = "description"
	// column name
	SaasRoleUpdateColumnID SaasRoleUpdateColumn = "id"
	// column name
	SaasRoleUpdateColumnUpdatedAt SaasRoleUpdateColumn = "updated_at"
)

var AllSaasRoleUpdateColumn = []SaasRoleUpdateColumn{
	SaasRoleUpdateColumnCreatedAt,
	SaasRoleUpdateColumnDescription,
	SaasRoleUpdateColumnID,
	SaasRoleUpdateColumnUpdatedAt,
}

func (e SaasRoleUpdateColumn) IsValid() bool {
	switch e {
	case SaasRoleUpdateColumnCreatedAt, SaasRoleUpdateColumnDescription, SaasRoleUpdateColumnID, SaasRoleUpdateColumnUpdatedAt:
		return true
	}
	return false
}

func (e SaasRoleUpdateColumn) String() string {
	return string(e)
}

func (e *SaasRoleUpdateColumn) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = SaasRoleUpdateColumn(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid saas_role_update_column", str)
	}
	return nil
}

func (e SaasRoleUpdateColumn) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// select columns of table "saas_user_account"
type SaasUserAccountSelectColumn string

const (
	// column name
	SaasUserAccountSelectColumnCreatedAt SaasUserAccountSelectColumn = "created_at"
	// column name
	SaasUserAccountSelectColumnID SaasUserAccountSelectColumn = "id"
	// column name
	SaasUserAccountSelectColumnIDUser SaasUserAccountSelectColumn = "id_user"
	// column name
	SaasUserAccountSelectColumnName SaasUserAccountSelectColumn = "name"
	// column name
	SaasUserAccountSelectColumnUpdatedAt SaasUserAccountSelectColumn = "updated_at"
)

var AllSaasUserAccountSelectColumn = []SaasUserAccountSelectColumn{
	SaasUserAccountSelectColumnCreatedAt,
	SaasUserAccountSelectColumnID,
	SaasUserAccountSelectColumnIDUser,
	SaasUserAccountSelectColumnName,
	SaasUserAccountSelectColumnUpdatedAt,
}

func (e SaasUserAccountSelectColumn) IsValid() bool {
	switch e {
	case SaasUserAccountSelectColumnCreatedAt, SaasUserAccountSelectColumnID, SaasUserAccountSelectColumnIDUser, SaasUserAccountSelectColumnName, SaasUserAccountSelectColumnUpdatedAt:
		return true
	}
	return false
}

func (e SaasUserAccountSelectColumn) String() string {
	return string(e)
}

func (e *SaasUserAccountSelectColumn) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = SaasUserAccountSelectColumn(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid saas_user_account_select_column", str)
	}
	return nil
}

func (e SaasUserAccountSelectColumn) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// select columns of table "subscription_active_plan"
type SubscriptionActivePlanSelectColumn string

const (
	// column name
	SubscriptionActivePlanSelectColumnDescription SubscriptionActivePlanSelectColumn = "description"
	// column name
	SubscriptionActivePlanSelectColumnID SubscriptionActivePlanSelectColumn = "id"
)

var AllSubscriptionActivePlanSelectColumn = []SubscriptionActivePlanSelectColumn{
	SubscriptionActivePlanSelectColumnDescription,
	SubscriptionActivePlanSelectColumnID,
}

func (e SubscriptionActivePlanSelectColumn) IsValid() bool {
	switch e {
	case SubscriptionActivePlanSelectColumnDescription, SubscriptionActivePlanSelectColumnID:
		return true
	}
	return false
}

func (e SubscriptionActivePlanSelectColumn) String() string {
	return string(e)
}

func (e *SubscriptionActivePlanSelectColumn) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = SubscriptionActivePlanSelectColumn(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid subscription_active_plan_select_column", str)
	}
	return nil
}

func (e SubscriptionActivePlanSelectColumn) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// unique or primary key constraints on table "subscription_customer"
type SubscriptionCustomerConstraint string

const (
	// unique or primary key constraint
	SubscriptionCustomerConstraintSubscriptionCustomerIDAccountKey SubscriptionCustomerConstraint = "subscription_customer_id_account_key"
	// unique or primary key constraint
	SubscriptionCustomerConstraintSubscriptionCustomerPkey SubscriptionCustomerConstraint = "subscription_customer_pkey"
)

var AllSubscriptionCustomerConstraint = []SubscriptionCustomerConstraint{
	SubscriptionCustomerConstraintSubscriptionCustomerIDAccountKey,
	SubscriptionCustomerConstraintSubscriptionCustomerPkey,
}

func (e SubscriptionCustomerConstraint) IsValid() bool {
	switch e {
	case SubscriptionCustomerConstraintSubscriptionCustomerIDAccountKey, SubscriptionCustomerConstraintSubscriptionCustomerPkey:
		return true
	}
	return false
}

func (e SubscriptionCustomerConstraint) String() string {
	return string(e)
}

func (e *SubscriptionCustomerConstraint) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = SubscriptionCustomerConstraint(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid subscription_customer_constraint", str)
	}
	return nil
}

func (e SubscriptionCustomerConstraint) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// select columns of table "subscription_customer"
type SubscriptionCustomerSelectColumn string

const (
	// column name
	SubscriptionCustomerSelectColumnCreatedAt SubscriptionCustomerSelectColumn = "created_at"
	// column name
	SubscriptionCustomerSelectColumnID SubscriptionCustomerSelectColumn = "id"
	// column name
	SubscriptionCustomerSelectColumnIDAccount SubscriptionCustomerSelectColumn = "id_account"
	// column name
	SubscriptionCustomerSelectColumnStripeCustomer SubscriptionCustomerSelectColumn = "stripe_customer"
	// column name
	SubscriptionCustomerSelectColumnUpdatedAt SubscriptionCustomerSelectColumn = "updated_at"
)

var AllSubscriptionCustomerSelectColumn = []SubscriptionCustomerSelectColumn{
	SubscriptionCustomerSelectColumnCreatedAt,
	SubscriptionCustomerSelectColumnID,
	SubscriptionCustomerSelectColumnIDAccount,
	SubscriptionCustomerSelectColumnStripeCustomer,
	SubscriptionCustomerSelectColumnUpdatedAt,
}

func (e SubscriptionCustomerSelectColumn) IsValid() bool {
	switch e {
	case SubscriptionCustomerSelectColumnCreatedAt, SubscriptionCustomerSelectColumnID, SubscriptionCustomerSelectColumnIDAccount, SubscriptionCustomerSelectColumnStripeCustomer, SubscriptionCustomerSelectColumnUpdatedAt:
		return true
	}
	return false
}

func (e SubscriptionCustomerSelectColumn) String() string {
	return string(e)
}

func (e *SubscriptionCustomerSelectColumn) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = SubscriptionCustomerSelectColumn(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid subscription_customer_select_column", str)
	}
	return nil
}

func (e SubscriptionCustomerSelectColumn) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// update columns of table "subscription_customer"
type SubscriptionCustomerUpdateColumn string

const (
	// column name
	SubscriptionCustomerUpdateColumnCreatedAt SubscriptionCustomerUpdateColumn = "created_at"
	// column name
	SubscriptionCustomerUpdateColumnID SubscriptionCustomerUpdateColumn = "id"
	// column name
	SubscriptionCustomerUpdateColumnIDAccount SubscriptionCustomerUpdateColumn = "id_account"
	// column name
	SubscriptionCustomerUpdateColumnStripeCustomer SubscriptionCustomerUpdateColumn = "stripe_customer"
	// column name
	SubscriptionCustomerUpdateColumnUpdatedAt SubscriptionCustomerUpdateColumn = "updated_at"
)

var AllSubscriptionCustomerUpdateColumn = []SubscriptionCustomerUpdateColumn{
	SubscriptionCustomerUpdateColumnCreatedAt,
	SubscriptionCustomerUpdateColumnID,
	SubscriptionCustomerUpdateColumnIDAccount,
	SubscriptionCustomerUpdateColumnStripeCustomer,
	SubscriptionCustomerUpdateColumnUpdatedAt,
}

func (e SubscriptionCustomerUpdateColumn) IsValid() bool {
	switch e {
	case SubscriptionCustomerUpdateColumnCreatedAt, SubscriptionCustomerUpdateColumnID, SubscriptionCustomerUpdateColumnIDAccount, SubscriptionCustomerUpdateColumnStripeCustomer, SubscriptionCustomerUpdateColumnUpdatedAt:
		return true
	}
	return false
}

func (e SubscriptionCustomerUpdateColumn) String() string {
	return string(e)
}

func (e *SubscriptionCustomerUpdateColumn) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = SubscriptionCustomerUpdateColumn(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid subscription_customer_update_column", str)
	}
	return nil
}

func (e SubscriptionCustomerUpdateColumn) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// unique or primary key constraints on table "subscription_event"
type SubscriptionEventConstraint string

const (
	// unique or primary key constraint
	SubscriptionEventConstraintSubscriptionEventPkey SubscriptionEventConstraint = "subscription_event_pkey"
)

var AllSubscriptionEventConstraint = []SubscriptionEventConstraint{
	SubscriptionEventConstraintSubscriptionEventPkey,
}

func (e SubscriptionEventConstraint) IsValid() bool {
	switch e {
	case SubscriptionEventConstraintSubscriptionEventPkey:
		return true
	}
	return false
}

func (e SubscriptionEventConstraint) String() string {
	return string(e)
}

func (e *SubscriptionEventConstraint) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = SubscriptionEventConstraint(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid subscription_event_constraint", str)
	}
	return nil
}

func (e SubscriptionEventConstraint) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// select columns of table "subscription_event"
type SubscriptionEventSelectColumn string

const (
	// column name
	SubscriptionEventSelectColumnCreatedAt SubscriptionEventSelectColumn = "created_at"
	// column name
	SubscriptionEventSelectColumnData SubscriptionEventSelectColumn = "data"
	// column name
	SubscriptionEventSelectColumnID SubscriptionEventSelectColumn = "id"
	// column name
	SubscriptionEventSelectColumnType SubscriptionEventSelectColumn = "type"
	// column name
	SubscriptionEventSelectColumnUpdatedAt SubscriptionEventSelectColumn = "updated_at"
)

var AllSubscriptionEventSelectColumn = []SubscriptionEventSelectColumn{
	SubscriptionEventSelectColumnCreatedAt,
	SubscriptionEventSelectColumnData,
	SubscriptionEventSelectColumnID,
	SubscriptionEventSelectColumnType,
	SubscriptionEventSelectColumnUpdatedAt,
}

func (e SubscriptionEventSelectColumn) IsValid() bool {
	switch e {
	case SubscriptionEventSelectColumnCreatedAt, SubscriptionEventSelectColumnData, SubscriptionEventSelectColumnID, SubscriptionEventSelectColumnType, SubscriptionEventSelectColumnUpdatedAt:
		return true
	}
	return false
}

func (e SubscriptionEventSelectColumn) String() string {
	return string(e)
}

func (e *SubscriptionEventSelectColumn) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = SubscriptionEventSelectColumn(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid subscription_event_select_column", str)
	}
	return nil
}

func (e SubscriptionEventSelectColumn) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// update columns of table "subscription_event"
type SubscriptionEventUpdateColumn string

const (
	// column name
	SubscriptionEventUpdateColumnCreatedAt SubscriptionEventUpdateColumn = "created_at"
	// column name
	SubscriptionEventUpdateColumnData SubscriptionEventUpdateColumn = "data"
	// column name
	SubscriptionEventUpdateColumnID SubscriptionEventUpdateColumn = "id"
	// column name
	SubscriptionEventUpdateColumnType SubscriptionEventUpdateColumn = "type"
	// column name
	SubscriptionEventUpdateColumnUpdatedAt SubscriptionEventUpdateColumn = "updated_at"
)

var AllSubscriptionEventUpdateColumn = []SubscriptionEventUpdateColumn{
	SubscriptionEventUpdateColumnCreatedAt,
	SubscriptionEventUpdateColumnData,
	SubscriptionEventUpdateColumnID,
	SubscriptionEventUpdateColumnType,
	SubscriptionEventUpdateColumnUpdatedAt,
}

func (e SubscriptionEventUpdateColumn) IsValid() bool {
	switch e {
	case SubscriptionEventUpdateColumnCreatedAt, SubscriptionEventUpdateColumnData, SubscriptionEventUpdateColumnID, SubscriptionEventUpdateColumnType, SubscriptionEventUpdateColumnUpdatedAt:
		return true
	}
	return false
}

func (e SubscriptionEventUpdateColumn) String() string {
	return string(e)
}

func (e *SubscriptionEventUpdateColumn) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = SubscriptionEventUpdateColumn(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid subscription_event_update_column", str)
	}
	return nil
}

func (e SubscriptionEventUpdateColumn) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// unique or primary key constraints on table "subscription_plan"
type SubscriptionPlanConstraint string

const (
	// unique or primary key constraint
	SubscriptionPlanConstraintSubscriptionPlanPkey SubscriptionPlanConstraint = "subscription_plan_pkey"
)

var AllSubscriptionPlanConstraint = []SubscriptionPlanConstraint{
	SubscriptionPlanConstraintSubscriptionPlanPkey,
}

func (e SubscriptionPlanConstraint) IsValid() bool {
	switch e {
	case SubscriptionPlanConstraintSubscriptionPlanPkey:
		return true
	}
	return false
}

func (e SubscriptionPlanConstraint) String() string {
	return string(e)
}

func (e *SubscriptionPlanConstraint) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = SubscriptionPlanConstraint(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid subscription_plan_constraint", str)
	}
	return nil
}

func (e SubscriptionPlanConstraint) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// select columns of table "subscription_plan"
type SubscriptionPlanSelectColumn string

const (
	// column name
	SubscriptionPlanSelectColumnCreatedAt SubscriptionPlanSelectColumn = "created_at"
	// column name
	SubscriptionPlanSelectColumnDescription SubscriptionPlanSelectColumn = "description"
	// column name
	SubscriptionPlanSelectColumnID SubscriptionPlanSelectColumn = "id"
	// column name
	SubscriptionPlanSelectColumnIsActive SubscriptionPlanSelectColumn = "is_active"
	// column name
	SubscriptionPlanSelectColumnStripeCode SubscriptionPlanSelectColumn = "stripe_code"
	// column name
	SubscriptionPlanSelectColumnUpdatedAt SubscriptionPlanSelectColumn = "updated_at"
)

var AllSubscriptionPlanSelectColumn = []SubscriptionPlanSelectColumn{
	SubscriptionPlanSelectColumnCreatedAt,
	SubscriptionPlanSelectColumnDescription,
	SubscriptionPlanSelectColumnID,
	SubscriptionPlanSelectColumnIsActive,
	SubscriptionPlanSelectColumnStripeCode,
	SubscriptionPlanSelectColumnUpdatedAt,
}

func (e SubscriptionPlanSelectColumn) IsValid() bool {
	switch e {
	case SubscriptionPlanSelectColumnCreatedAt, SubscriptionPlanSelectColumnDescription, SubscriptionPlanSelectColumnID, SubscriptionPlanSelectColumnIsActive, SubscriptionPlanSelectColumnStripeCode, SubscriptionPlanSelectColumnUpdatedAt:
		return true
	}
	return false
}

func (e SubscriptionPlanSelectColumn) String() string {
	return string(e)
}

func (e *SubscriptionPlanSelectColumn) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = SubscriptionPlanSelectColumn(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid subscription_plan_select_column", str)
	}
	return nil
}

func (e SubscriptionPlanSelectColumn) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// update columns of table "subscription_plan"
type SubscriptionPlanUpdateColumn string

const (
	// column name
	SubscriptionPlanUpdateColumnCreatedAt SubscriptionPlanUpdateColumn = "created_at"
	// column name
	SubscriptionPlanUpdateColumnDescription SubscriptionPlanUpdateColumn = "description"
	// column name
	SubscriptionPlanUpdateColumnID SubscriptionPlanUpdateColumn = "id"
	// column name
	SubscriptionPlanUpdateColumnIsActive SubscriptionPlanUpdateColumn = "is_active"
	// column name
	SubscriptionPlanUpdateColumnStripeCode SubscriptionPlanUpdateColumn = "stripe_code"
	// column name
	SubscriptionPlanUpdateColumnUpdatedAt SubscriptionPlanUpdateColumn = "updated_at"
)

var AllSubscriptionPlanUpdateColumn = []SubscriptionPlanUpdateColumn{
	SubscriptionPlanUpdateColumnCreatedAt,
	SubscriptionPlanUpdateColumnDescription,
	SubscriptionPlanUpdateColumnID,
	SubscriptionPlanUpdateColumnIsActive,
	SubscriptionPlanUpdateColumnStripeCode,
	SubscriptionPlanUpdateColumnUpdatedAt,
}

func (e SubscriptionPlanUpdateColumn) IsValid() bool {
	switch e {
	case SubscriptionPlanUpdateColumnCreatedAt, SubscriptionPlanUpdateColumnDescription, SubscriptionPlanUpdateColumnID, SubscriptionPlanUpdateColumnIsActive, SubscriptionPlanUpdateColumnStripeCode, SubscriptionPlanUpdateColumnUpdatedAt:
		return true
	}
	return false
}

func (e SubscriptionPlanUpdateColumn) String() string {
	return string(e)
}

func (e *SubscriptionPlanUpdateColumn) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = SubscriptionPlanUpdateColumn(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid subscription_plan_update_column", str)
	}
	return nil
}

func (e SubscriptionPlanUpdateColumn) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// unique or primary key constraints on table "subscription_status"
type SubscriptionStatusConstraint string

const (
	// unique or primary key constraint
	SubscriptionStatusConstraintSubscriptionStatusIDAccountKey SubscriptionStatusConstraint = "subscription_status_id_account_key"
	// unique or primary key constraint
	SubscriptionStatusConstraintSubscriptionStatusPkey SubscriptionStatusConstraint = "subscription_status_pkey"
)

var AllSubscriptionStatusConstraint = []SubscriptionStatusConstraint{
	SubscriptionStatusConstraintSubscriptionStatusIDAccountKey,
	SubscriptionStatusConstraintSubscriptionStatusPkey,
}

func (e SubscriptionStatusConstraint) IsValid() bool {
	switch e {
	case SubscriptionStatusConstraintSubscriptionStatusIDAccountKey, SubscriptionStatusConstraintSubscriptionStatusPkey:
		return true
	}
	return false
}

func (e SubscriptionStatusConstraint) String() string {
	return string(e)
}

func (e *SubscriptionStatusConstraint) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = SubscriptionStatusConstraint(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid subscription_status_constraint", str)
	}
	return nil
}

func (e SubscriptionStatusConstraint) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// select columns of table "subscription_status"
type SubscriptionStatusSelectColumn string

const (
	// column name
	SubscriptionStatusSelectColumnCreatedAt SubscriptionStatusSelectColumn = "created_at"
	// column name
	SubscriptionStatusSelectColumnID SubscriptionStatusSelectColumn = "id"
	// column name
	SubscriptionStatusSelectColumnIDAccount SubscriptionStatusSelectColumn = "id_account"
	// column name
	SubscriptionStatusSelectColumnIDPlan SubscriptionStatusSelectColumn = "id_plan"
	// column name
	SubscriptionStatusSelectColumnIsActive SubscriptionStatusSelectColumn = "is_active"
	// column name
	SubscriptionStatusSelectColumnStatus SubscriptionStatusSelectColumn = "status"
	// column name
	SubscriptionStatusSelectColumnStripeSubscriptionID SubscriptionStatusSelectColumn = "stripe_subscription_id"
	// column name
	SubscriptionStatusSelectColumnUpdatedAt SubscriptionStatusSelectColumn = "updated_at"
)

var AllSubscriptionStatusSelectColumn = []SubscriptionStatusSelectColumn{
	SubscriptionStatusSelectColumnCreatedAt,
	SubscriptionStatusSelectColumnID,
	SubscriptionStatusSelectColumnIDAccount,
	SubscriptionStatusSelectColumnIDPlan,
	SubscriptionStatusSelectColumnIsActive,
	SubscriptionStatusSelectColumnStatus,
	SubscriptionStatusSelectColumnStripeSubscriptionID,
	SubscriptionStatusSelectColumnUpdatedAt,
}

func (e SubscriptionStatusSelectColumn) IsValid() bool {
	switch e {
	case SubscriptionStatusSelectColumnCreatedAt, SubscriptionStatusSelectColumnID, SubscriptionStatusSelectColumnIDAccount, SubscriptionStatusSelectColumnIDPlan, SubscriptionStatusSelectColumnIsActive, SubscriptionStatusSelectColumnStatus, SubscriptionStatusSelectColumnStripeSubscriptionID, SubscriptionStatusSelectColumnUpdatedAt:
		return true
	}
	return false
}

func (e SubscriptionStatusSelectColumn) String() string {
	return string(e)
}

func (e *SubscriptionStatusSelectColumn) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = SubscriptionStatusSelectColumn(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid subscription_status_select_column", str)
	}
	return nil
}

func (e SubscriptionStatusSelectColumn) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// update columns of table "subscription_status"
type SubscriptionStatusUpdateColumn string

const (
	// column name
	SubscriptionStatusUpdateColumnCreatedAt SubscriptionStatusUpdateColumn = "created_at"
	// column name
	SubscriptionStatusUpdateColumnID SubscriptionStatusUpdateColumn = "id"
	// column name
	SubscriptionStatusUpdateColumnIDAccount SubscriptionStatusUpdateColumn = "id_account"
	// column name
	SubscriptionStatusUpdateColumnIDPlan SubscriptionStatusUpdateColumn = "id_plan"
	// column name
	SubscriptionStatusUpdateColumnIsActive SubscriptionStatusUpdateColumn = "is_active"
	// column name
	SubscriptionStatusUpdateColumnStatus SubscriptionStatusUpdateColumn = "status"
	// column name
	SubscriptionStatusUpdateColumnStripeSubscriptionID SubscriptionStatusUpdateColumn = "stripe_subscription_id"
	// column name
	SubscriptionStatusUpdateColumnUpdatedAt SubscriptionStatusUpdateColumn = "updated_at"
)

var AllSubscriptionStatusUpdateColumn = []SubscriptionStatusUpdateColumn{
	SubscriptionStatusUpdateColumnCreatedAt,
	SubscriptionStatusUpdateColumnID,
	SubscriptionStatusUpdateColumnIDAccount,
	SubscriptionStatusUpdateColumnIDPlan,
	SubscriptionStatusUpdateColumnIsActive,
	SubscriptionStatusUpdateColumnStatus,
	SubscriptionStatusUpdateColumnStripeSubscriptionID,
	SubscriptionStatusUpdateColumnUpdatedAt,
}

func (e SubscriptionStatusUpdateColumn) IsValid() bool {
	switch e {
	case SubscriptionStatusUpdateColumnCreatedAt, SubscriptionStatusUpdateColumnID, SubscriptionStatusUpdateColumnIDAccount, SubscriptionStatusUpdateColumnIDPlan, SubscriptionStatusUpdateColumnIsActive, SubscriptionStatusUpdateColumnStatus, SubscriptionStatusUpdateColumnStripeSubscriptionID, SubscriptionStatusUpdateColumnUpdatedAt:
		return true
	}
	return false
}

func (e SubscriptionStatusUpdateColumn) String() string {
	return string(e)
}

func (e *SubscriptionStatusUpdateColumn) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = SubscriptionStatusUpdateColumn(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid subscription_status_update_column", str)
	}
	return nil
}

func (e SubscriptionStatusUpdateColumn) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}
